/* automatically generated by rust-bindgen 0.59.2 */

pub const __GMP_HAVE_HOST_CPU_FAMILY_power: u32 = 0;
pub const __GMP_HAVE_HOST_CPU_FAMILY_powerpc: u32 = 0;
pub const GMP_LIMB_BITS: u32 = 64;
pub const GMP_NAIL_BITS: u32 = 0;
pub const GMP_NUMB_BITS: u32 = 64;
pub const __GNU_MP__: u32 = 6;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const __GMP_LIBGMP_DLL: u32 = 0;
pub const __GMP_MP_SIZE_T_INT: u32 = 0;
pub const __GMP_INLINE_PROTOTYPES: u32 = 1;
pub const __GMP_CC: &[u8; 4usize] = b"gcc\0";
pub const __GMP_CFLAGS : & [u8 ; 367usize] = b"-O2 -flto=auto -ffat-lto-objects -fexceptions -g -grecord-gcc-switches -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -Wp,-D_GLIBCXX_ASSERTIONS -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -fstack-protector-strong -specs=/usr/lib/rpm/redhat/redhat-annobin-cc1  -m64  -mtune=generic -fasynchronous-unwind-tables -fstack-clash-protection -fcf-protection\0" ;
pub const __GNU_MP_VERSION: u32 = 6;
pub const __GNU_MP_VERSION_MINOR: u32 = 2;
pub const __GNU_MP_VERSION_PATCHLEVEL: u32 = 1;
pub const __GNU_MP_RELEASE: u32 = 60201;
pub const _STDINT_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _SYS_TIME_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const SCM_HAVE_STDC_HEADERS: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const SCM_HAVE_SYS_SELECT_H: u32 = 1;
pub const SCM_HAVE_WINSOCK2_H: u32 = 0;
pub const SCM_ENABLE_DEPRECATED: u32 = 1;
pub const SCM_STACK_GROWS_UP: u32 = 0;
pub const SCM_SIZEOF_CHAR: u32 = 1;
pub const SCM_SIZEOF_UNSIGNED_CHAR: u32 = 1;
pub const SCM_SIZEOF_SHORT: u32 = 2;
pub const SCM_SIZEOF_UNSIGNED_SHORT: u32 = 2;
pub const SCM_SIZEOF_LONG: u32 = 8;
pub const SCM_SIZEOF_UNSIGNED_LONG: u32 = 8;
pub const SCM_SIZEOF_INT: u32 = 4;
pub const SCM_SIZEOF_UNSIGNED_INT: u32 = 4;
pub const SCM_SIZEOF_SIZE_T: u32 = 8;
pub const SCM_SIZEOF_LONG_LONG: u32 = 8;
pub const SCM_SIZEOF_UNSIGNED_LONG_LONG: u32 = 8;
pub const SCM_SIZEOF_INTMAX: u32 = 8;
pub const SCM_HAVE_T_INT64: u32 = 1;
pub const SCM_HAVE_T_UINT64: u32 = 1;
pub const SCM_SIZEOF_SCM_T_PTRDIFF: u32 = 8;
pub const SCM_SIZEOF_INTPTR_T: u32 = 8;
pub const SCM_SIZEOF_UINTPTR_T: u32 = 8;
pub const SCM_USE_PTHREAD_THREADS: u32 = 1;
pub const SCM_USE_NULL_THREADS: u32 = 0;
pub const SCM_NEED_BRACES_ON_PTHREAD_ONCE_INIT: u32 = 0;
pub const SCM_NEED_BRACES_ON_PTHREAD_MUTEX_INITIALIZER: u32 = 0;
pub const SCM_HAVE_GC_PTHREAD_CANCEL: u32 = 1;
pub const SCM_HAVE_GC_PTHREAD_EXIT: u32 = 1;
pub const SCM_HAVE_GC_PTHREAD_SIGMASK: u32 = 1;
pub const SCM_HAVE_STRUCT_DIRENT64: u32 = 1;
pub const SCM_HAVE_READDIR64_R: u32 = 1;
pub const USE_THREADS: u32 = 1;
pub const GUILE_ISELECT: u32 = 1;
pub const READER_EXTENSIONS: u32 = 1;
pub const DEBUG_EXTENSIONS: u32 = 1;
pub const DYNAMIC_LINKING: u32 = 1;
pub const SCM_HAVE_ARRAYS: u32 = 1;
pub const SCM_ICONVEH_ERROR: u32 = 0;
pub const SCM_ICONVEH_QUESTION_MARK: u32 = 1;
pub const SCM_ICONVEH_ESCAPE_SEQUENCE: u32 = 2;
pub const SCM_CAN_INLINE: u32 = 1;
pub const SCM_DEBUG: u32 = 0;
pub const SCM_DEBUG_MARKING_API: u32 = 0;
pub const SCM_DEBUG_CELL_ACCESSES: u32 = 0;
pub const SCM_DEBUG_INTERRUPTS: u32 = 0;
pub const SCM_DEBUG_PAIR_ACCESSES: u32 = 0;
pub const SCM_DEBUG_REST_ARGUMENT: u32 = 0;
pub const SCM_DEBUG_TYPING_STRICTNESS: u32 = 1;
pub const SCM_DEBUG_DEBUGGING_SUPPORT: u32 = 0;
pub const SCM_LONG_BIT: u32 = 64;
pub const scm_tc2_int: u32 = 2;
pub const scm_tc3_cons: u32 = 0;
pub const scm_tc3_struct: u32 = 1;
pub const scm_tc3_int_1: u32 = 2;
pub const scm_tc3_unused: u32 = 3;
pub const scm_tc3_imm24: u32 = 4;
pub const scm_tc3_tc7_1: u32 = 5;
pub const scm_tc3_int_2: u32 = 6;
pub const scm_tc3_tc7_2: u32 = 7;
pub const scm_tc7_symbol: u32 = 5;
pub const scm_tc7_variable: u32 = 7;
pub const scm_tc7_vector: u32 = 13;
pub const scm_tc7_wvect: u32 = 15;
pub const scm_tc7_string: u32 = 21;
pub const scm_tc7_number: u32 = 23;
pub const scm_tc7_stringbuf: u32 = 39;
pub const scm_tc7_bytevector: u32 = 77;
pub const scm_tc7_pointer: u32 = 31;
pub const scm_tc7_hashtable: u32 = 29;
pub const scm_tc7_fluid: u32 = 37;
pub const scm_tc7_dynamic_state: u32 = 45;
pub const scm_tc7_frame: u32 = 47;
pub const scm_tc7_objcode: u32 = 53;
pub const scm_tc7_vm: u32 = 55;
pub const scm_tc7_vm_cont: u32 = 71;
pub const scm_tc7_prompt: u32 = 61;
pub const scm_tc7_with_fluids: u32 = 63;
pub const scm_tc7_unused_19: u32 = 69;
pub const scm_tc7_program: u32 = 79;
pub const scm_tc7_array: u32 = 85;
pub const scm_tc7_bitvector: u32 = 87;
pub const scm_tc7_unused_20: u32 = 93;
pub const scm_tc7_unused_11: u32 = 95;
pub const scm_tc7_unused_12: u32 = 101;
pub const scm_tc7_unused_18: u32 = 103;
pub const scm_tc7_unused_13: u32 = 109;
pub const scm_tc7_unused_14: u32 = 111;
pub const scm_tc7_unused_15: u32 = 117;
pub const scm_tc7_unused_16: u32 = 119;
pub const scm_tc7_port: u32 = 125;
pub const scm_tc7_smob: u32 = 127;
pub const _SETJMP_H: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const SCM_ARGn: u32 = 0;
pub const SCM_ARG1: u32 = 1;
pub const SCM_ARG2: u32 = 2;
pub const SCM_ARG3: u32 = 3;
pub const SCM_ARG4: u32 = 4;
pub const SCM_ARG5: u32 = 5;
pub const SCM_ARG6: u32 = 6;
pub const SCM_ARG7: u32 = 7;
pub const SCM_EXIT_SUCCESS: u32 = 0;
pub const SCM_EXIT_FAILURE: u32 = 1;
pub const SCM_CODEPOINT_DOTTED_CIRCLE: u32 = 9676;
pub const SCM_CODEPOINT_SURROGATE_START: u32 = 55296;
pub const SCM_CODEPOINT_SURROGATE_END: u32 = 57343;
pub const SCM_CODEPOINT_MAX: u32 = 1114111;
pub const SCM_OPTION_BOOLEAN: u32 = 0;
pub const SCM_OPTION_INTEGER: u32 = 1;
pub const SCM_OPTION_SCM: u32 = 2;
pub const SCM_PRINT_STATE_LAYOUT: &[u8; 25usize] = b"sruwuwuwuwuwpwuwuwurprpw\0";
pub const SCM_I_FIXNUM_BIT: u32 = 62;
pub const SCM_MOST_NEGATIVE_FIXNUM: i64 = -2305843009213693952;
pub const SCM_MOST_POSITIVE_FIXNUM: u64 = 2305843009213693951;
pub const scm_tc16_big: u32 = 279;
pub const scm_tc16_real: u32 = 535;
pub const scm_tc16_complex: u32 = 791;
pub const scm_tc16_fraction: u32 = 1047;
pub const SCM_I_ARRAY_FLAG_CONTIGUOUS: u32 = 1;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const GC_THREADS: u32 = 1;
pub const GC_REDIRECT_TO_LOCAL: u32 = 1;
pub const GC_NO_THREAD_REDIRECTS: u32 = 1;
pub const GC_TMP_VERSION_MAJOR: u32 = 8;
pub const GC_TMP_VERSION_MINOR: u32 = 0;
pub const GC_TMP_VERSION_MICRO: u32 = 6;
pub const GC_VERSION_MAJOR: u32 = 8;
pub const GC_VERSION_MINOR: u32 = 0;
pub const GC_VERSION_MICRO: u32 = 6;
pub const _REENTRANT: u32 = 1;
pub const GC_TIME_UNLIMITED: u32 = 999999;
pub const GC_PROTECTS_POINTER_HEAP: u32 = 1;
pub const GC_PROTECTS_PTRFREE_HEAP: u32 = 2;
pub const GC_PROTECTS_STATIC_DATA: u32 = 4;
pub const GC_PROTECTS_STACK: u32 = 8;
pub const GC_PROTECTS_NONE: u32 = 0;
pub const GC_NO_MEMORY: u32 = 2;
pub const GC_SUCCESS: u32 = 0;
pub const GC_DUPLICATE: u32 = 1;
pub const GC_NO_THREADS: u32 = 2;
pub const GC_UNIMPLEMENTED: u32 = 3;
pub const GC_NOT_FOUND: u32 = 4;
pub const _DLFCN_H: u32 = 1;
pub const RTLD_LAZY: u32 = 1;
pub const RTLD_NOW: u32 = 2;
pub const RTLD_BINDING_MASK: u32 = 3;
pub const RTLD_NOLOAD: u32 = 4;
pub const RTLD_DEEPBIND: u32 = 8;
pub const RTLD_GLOBAL: u32 = 256;
pub const RTLD_LOCAL: u32 = 0;
pub const RTLD_NODELETE: u32 = 4096;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGIOT: u32 = 6;
pub const _BITS_SIGNUM_ARCH_H: u32 = 1;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const SIGBUS: u32 = 7;
pub const SIGSYS: u32 = 31;
pub const SIGURG: u32 = 23;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGCONT: u32 = 18;
pub const SIGCHLD: u32 = 17;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 29;
pub const SIGXFSZ: u32 = 25;
pub const SIGXCPU: u32 = 24;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 10;
pub const SIGUSR2: u32 = 12;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGCLD: u32 = 17;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 64;
pub const _NSIG: u32 = 65;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 1;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 65;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 23;
pub const NGREG: u32 = 23;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const SCM_I_PTHREAD_ONCE_INIT: u32 = 0;
pub const SCM_BYTEVECTOR_HEADER_SIZE: u32 = 3;
pub const SCM_GC_BYTEVECTOR: &[u8; 11usize] = b"bytevector\0";
pub const SCM_VTABLE_BASE_LAYOUT: &[u8; 17usize] = b"pruhsruhpwphuhuh\0";
pub const scm_vtable_index_layout: u32 = 0;
pub const scm_vtable_index_flags: u32 = 1;
pub const scm_vtable_index_self: u32 = 2;
pub const scm_vtable_index_instance_finalize: u32 = 3;
pub const scm_vtable_index_instance_printer: u32 = 4;
pub const scm_vtable_index_name: u32 = 5;
pub const scm_vtable_index_size: u32 = 6;
pub const scm_vtable_index_reserved_7: u32 = 7;
pub const scm_vtable_offset_user: u32 = 8;
pub const SCM_APPLICABLE_BASE_LAYOUT: &[u8; 3usize] = b"pw\0";
pub const SCM_APPLICABLE_WITH_SETTER_BASE_LAYOUT: &[u8; 5usize] = b"pwpw\0";
pub const scm_applicable_struct_index_procedure: u32 = 0;
pub const scm_applicable_struct_index_setter: u32 = 1;
pub const SCM_VTABLE_FLAG_VALIDATED: u32 = 1;
pub const SCM_VTABLE_FLAG_VTABLE: u32 = 2;
pub const SCM_VTABLE_FLAG_APPLICABLE_VTABLE: u32 = 4;
pub const SCM_VTABLE_FLAG_APPLICABLE: u32 = 8;
pub const SCM_VTABLE_FLAG_SETTER_VTABLE: u32 = 16;
pub const SCM_VTABLE_FLAG_SETTER: u32 = 32;
pub const SCM_VTABLE_FLAG_SIMPLE: u32 = 64;
pub const SCM_VTABLE_FLAG_SIMPLE_RW: u32 = 128;
pub const SCM_VTABLE_FLAG_RESERVED_0: u32 = 256;
pub const SCM_VTABLE_FLAG_RESERVED_1: u32 = 512;
pub const SCM_VTABLE_FLAG_RESERVED_2: u32 = 1024;
pub const SCM_VTABLE_FLAG_SMOB_0: u32 = 2048;
pub const SCM_VTABLE_FLAG_GOOPS_0: u32 = 4096;
pub const SCM_VTABLE_FLAG_GOOPS_1: u32 = 8192;
pub const SCM_VTABLE_FLAG_GOOPS_2: u32 = 16384;
pub const SCM_VTABLE_FLAG_GOOPS_3: u32 = 32768;
pub const SCM_VTABLE_USER_FLAG_SHIFT: u32 = 16;
pub const SCM_DIR_FLAG_OPEN: u32 = 1;
pub const SCM_I_VECTOR_HEADER_SIZE: u32 = 2;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48usize] =
    b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5usize] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5usize] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const scm_tc7_ro_string: u32 = 533;
pub const SCM_I_STRINGBUF_F_SHARED: u32 = 256;
pub const SCM_I_STRINGBUF_F_WIDE: u32 = 1024;
pub const SCM_INITIAL_PUTBACK_BUF_SIZE: u32 = 4;
pub const SCM_OPN: u32 = 65536;
pub const SCM_RDNG: u32 = 131072;
pub const SCM_WRTNG: u32 = 262144;
pub const SCM_BUF0: u32 = 524288;
pub const SCM_BUFLINE: u32 = 4194304;
pub const SCM_I_MAX_PORT_TYPE_COUNT: u32 = 256;
pub const scm_gc_running_p: u32 = 0;
pub const SCM_VTABLE_FLAG_GOOPS_CLASS: u32 = 4096;
pub const SCM_VTABLE_FLAG_GOOPS_VALID: u32 = 8192;
pub const SCM_VTABLE_FLAG_GOOPS_PURE_GENERIC: u32 = 16384;
pub const SCM_CLASSF_METACLASS: u32 = 4098;
pub const SCM_CLASSF_PURE_GENERIC: u32 = 16384;
pub const SCM_CLASSF_GOOPS_VALID: u32 = 8192;
pub const SCM_CLASSF_GOOPS: u32 = 4096;
pub const SCM_CLASSF_GOOPS_OR_VALID: u32 = 12288;
pub const SCM_CLASS_CLASS_LAYOUT: &[u8; 39usize] = b"pwuwuwuwuwuwuwuwuwpwpwpwpwpwpwpwpwpwpw\0";
pub const scm_si_redefined: u32 = 8;
pub const scm_si_h0: u32 = 9;
pub const scm_si_hashsets: u32 = 9;
pub const scm_si_h1: u32 = 10;
pub const scm_si_h2: u32 = 11;
pub const scm_si_h3: u32 = 12;
pub const scm_si_h4: u32 = 13;
pub const scm_si_h5: u32 = 14;
pub const scm_si_h6: u32 = 15;
pub const scm_si_h7: u32 = 16;
pub const scm_si_direct_supers: u32 = 17;
pub const scm_si_direct_slots: u32 = 18;
pub const scm_si_direct_subclasses: u32 = 19;
pub const scm_si_direct_methods: u32 = 20;
pub const scm_si_cpl: u32 = 21;
pub const scm_si_slotdef_class: u32 = 22;
pub const scm_si_slots: u32 = 23;
pub const scm_si_name_access: u32 = 24;
pub const scm_si_getters_n_setters: u32 = 24;
pub const scm_si_keyword_access: u32 = 25;
pub const scm_si_nfields: u32 = 26;
pub const SCM_N_CLASS_SLOTS: u32 = 27;
pub const scm_si_dispatch_procedure: u32 = 0;
pub const scm_si_methods: u32 = 1;
pub const scm_si_n_specialized: u32 = 2;
pub const scm_si_extended_by: u32 = 3;
pub const scm_si_effective_methods: u32 = 4;
pub const scm_si_generic_setter: u32 = 5;
pub const scm_si_generic_function: u32 = 0;
pub const scm_si_specializers: u32 = 1;
pub const scm_si_procedure: u32 = 2;
pub const scm_si_formals: u32 = 3;
pub const scm_si_body: u32 = 4;
pub const scm_si_make_procedure: u32 = 5;
pub const SCM_GSUBR_MAX: u32 = 10;
pub const SCM_WVECTF_WEAK_KEY: u32 = 1;
pub const SCM_WVECTF_WEAK_VALUE: u32 = 2;
pub const SCM_HASHTABLEF_WEAK_CAR: u32 = 1;
pub const SCM_HASHTABLEF_WEAK_CDR: u32 = 2;
pub const scm_module_index_obarray: u32 = 0;
pub const scm_module_index_uses: u32 = 1;
pub const scm_module_index_binder: u32 = 2;
pub const scm_module_index_eval_closure: u32 = 3;
pub const scm_module_index_transformer: u32 = 4;
pub const scm_module_index_duplicate_handlers: u32 = 7;
pub const scm_module_index_import_obarray: u32 = 8;
pub const SCM_F_PROMISE_COMPUTED: u32 = 1;
pub const SCM_LINE_INCREMENTORS: u8 = 10u8;
pub const SCM_SMOB_TYPE_MASK: u32 = 65535;
pub const SCM_I_MAX_SMOB_TYPE_COUNT: u32 = 256;
pub const SCM_SOURCE_PROPERTY_FLAG_BREAK: u32 = 1;
pub const SCM_I_F_SYMBOL_UNINTERNED: u32 = 256;
pub const SCM_MAJOR_VERSION: u32 = 2;
pub const SCM_MINOR_VERSION: u32 = 0;
pub const SCM_MICRO_VERSION: u32 = 14;
pub const SCM_EFFECTIVE_VERSION: &[u8; 4usize] = b"2.0\0";
pub const SCM_OBJCODE_TYPE_MMAP: u32 = 0;
pub const SCM_OBJCODE_TYPE_BYTEVECTOR: u32 = 1;
pub const SCM_OBJCODE_TYPE_SLICE: u32 = 2;
pub const SCM_OBJCODE_TYPE_STATIC: u32 = 3;
pub const SCM_F_PROGRAM_IS_BOOT: u32 = 256;
pub const SCM_F_PROGRAM_IS_PRIMITIVE: u32 = 512;
pub const SCM_F_PROGRAM_IS_PRIMITIVE_GENERIC: u32 = 1024;
pub const SCM_F_PROGRAM_IS_CONTINUATION: u32 = 2048;
pub const SCM_F_PROGRAM_IS_PARTIAL_CONTINUATION: u32 = 4096;
pub const SCM_STACK_LAYOUT: &[u8; 7usize] = b"pwpwpw\0";
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const SCM_IFRINC: u32 = 256;
pub const SCM_ICDR: u32 = 524288;
pub const scm_vtable_index_vtable: u32 = 2;
pub const scm_vtable_index_printer: u32 = 4;
pub const scm_struct_i_free: u32 = 3;
pub const scm_struct_i_flags: u32 = 1;
pub const SCM_WNA: u32 = 8;
pub const SCM_OUTOFRANGE: u32 = 10;
pub const SCM_NALLOC: u32 = 11;
pub const scm_tc7_ssymbol: u32 = 5;
pub const scm_tc7_msymbol: u32 = 5;
pub const scm_tcs_symbols: u32 = 5;
pub const SCM_VECTOR_MAX_LENGTH: u32 = 16777215;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type mp_limb_t = ::std::os::raw::c_ulong;
pub type mp_limb_signed_t = ::std::os::raw::c_long;
pub type mp_bitcnt_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mpz_struct {
    pub _mp_alloc: ::std::os::raw::c_int,
    pub _mp_size: ::std::os::raw::c_int,
    pub _mp_d: *mut mp_limb_t,
}
#[test]
fn bindgen_test_layout___mpz_struct() {
    assert_eq!(
        ::std::mem::size_of::<__mpz_struct>(),
        16usize,
        concat!("Size of: ", stringify!(__mpz_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__mpz_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__mpz_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mpz_struct>()))._mp_alloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpz_struct),
            "::",
            stringify!(_mp_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mpz_struct>()))._mp_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpz_struct),
            "::",
            stringify!(_mp_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mpz_struct>()))._mp_d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpz_struct),
            "::",
            stringify!(_mp_d)
        )
    );
}
pub type MP_INT = __mpz_struct;
pub type mpz_t = [__mpz_struct; 1usize];
pub type mp_ptr = *mut mp_limb_t;
pub type mp_srcptr = *const mp_limb_t;
pub type mp_size_t = ::std::os::raw::c_long;
pub type mp_exp_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mpq_struct {
    pub _mp_num: __mpz_struct,
    pub _mp_den: __mpz_struct,
}
#[test]
fn bindgen_test_layout___mpq_struct() {
    assert_eq!(
        ::std::mem::size_of::<__mpq_struct>(),
        32usize,
        concat!("Size of: ", stringify!(__mpq_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__mpq_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__mpq_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mpq_struct>()))._mp_num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpq_struct),
            "::",
            stringify!(_mp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mpq_struct>()))._mp_den as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpq_struct),
            "::",
            stringify!(_mp_den)
        )
    );
}
pub type MP_RAT = __mpq_struct;
pub type mpq_t = [__mpq_struct; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mpf_struct {
    pub _mp_prec: ::std::os::raw::c_int,
    pub _mp_size: ::std::os::raw::c_int,
    pub _mp_exp: mp_exp_t,
    pub _mp_d: *mut mp_limb_t,
}
#[test]
fn bindgen_test_layout___mpf_struct() {
    assert_eq!(
        ::std::mem::size_of::<__mpf_struct>(),
        24usize,
        concat!("Size of: ", stringify!(__mpf_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__mpf_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__mpf_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mpf_struct>()))._mp_prec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpf_struct),
            "::",
            stringify!(_mp_prec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mpf_struct>()))._mp_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpf_struct),
            "::",
            stringify!(_mp_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mpf_struct>()))._mp_exp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpf_struct),
            "::",
            stringify!(_mp_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mpf_struct>()))._mp_d as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpf_struct),
            "::",
            stringify!(_mp_d)
        )
    );
}
pub type mpf_t = [__mpf_struct; 1usize];
pub const gmp_randalg_t_GMP_RAND_ALG_DEFAULT: gmp_randalg_t = 0;
pub const gmp_randalg_t_GMP_RAND_ALG_LC: gmp_randalg_t = 0;
pub type gmp_randalg_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __gmp_randstate_struct {
    pub _mp_seed: mpz_t,
    pub _mp_alg: gmp_randalg_t,
    pub _mp_algdata: __gmp_randstate_struct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __gmp_randstate_struct__bindgen_ty_1 {
    pub _mp_lc: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___gmp_randstate_struct__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__gmp_randstate_struct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__gmp_randstate_struct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gmp_randstate_struct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__gmp_randstate_struct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__gmp_randstate_struct__bindgen_ty_1>()))._mp_lc as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gmp_randstate_struct__bindgen_ty_1),
            "::",
            stringify!(_mp_lc)
        )
    );
}
#[test]
fn bindgen_test_layout___gmp_randstate_struct() {
    assert_eq!(
        ::std::mem::size_of::<__gmp_randstate_struct>(),
        32usize,
        concat!("Size of: ", stringify!(__gmp_randstate_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__gmp_randstate_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__gmp_randstate_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__gmp_randstate_struct>()))._mp_seed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gmp_randstate_struct),
            "::",
            stringify!(_mp_seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__gmp_randstate_struct>()))._mp_alg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__gmp_randstate_struct),
            "::",
            stringify!(_mp_alg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__gmp_randstate_struct>()))._mp_algdata as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__gmp_randstate_struct),
            "::",
            stringify!(_mp_algdata)
        )
    );
}
pub type gmp_randstate_t = [__gmp_randstate_struct; 1usize];
pub type mpz_srcptr = *const __mpz_struct;
pub type mpz_ptr = *mut __mpz_struct;
pub type mpf_srcptr = *const __mpf_struct;
pub type mpf_ptr = *mut __mpf_struct;
pub type mpq_srcptr = *const __mpq_struct;
pub type mpq_ptr = *mut __mpq_struct;
extern "C" {
    pub fn __gmp_set_memory_functions(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(arg1: size_t) -> *mut ::std::os::raw::c_void,
        >,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: size_t,
                arg3: size_t,
            ) -> *mut ::std::os::raw::c_void,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: size_t),
        >,
    );
}
extern "C" {
    pub fn __gmp_get_memory_functions(
        arg1: *mut ::std::option::Option<
            unsafe extern "C" fn(arg1: size_t) -> *mut ::std::os::raw::c_void,
        >,
        arg2: *mut ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: size_t,
                arg3: size_t,
            ) -> *mut ::std::os::raw::c_void,
        >,
        arg3: *mut ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: size_t),
        >,
    );
}
extern "C" {
    pub static __gmp_bits_per_limb: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __gmp_errno: ::std::os::raw::c_int;
}
extern "C" {
    pub static __gmp_version: *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn __gmp_randinit(arg1: *mut __gmp_randstate_struct, arg2: gmp_randalg_t, ...);
}
extern "C" {
    pub fn __gmp_randinit_default(arg1: *mut __gmp_randstate_struct);
}
extern "C" {
    pub fn __gmp_randinit_lc_2exp(
        arg1: *mut __gmp_randstate_struct,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
        arg4: mp_bitcnt_t,
    );
}
extern "C" {
    pub fn __gmp_randinit_lc_2exp_size(
        arg1: *mut __gmp_randstate_struct,
        arg2: mp_bitcnt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_randinit_mt(arg1: *mut __gmp_randstate_struct);
}
extern "C" {
    pub fn __gmp_randinit_set(
        arg1: *mut __gmp_randstate_struct,
        arg2: *const __gmp_randstate_struct,
    );
}
extern "C" {
    pub fn __gmp_randseed(arg1: *mut __gmp_randstate_struct, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmp_randseed_ui(arg1: *mut __gmp_randstate_struct, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmp_randclear(arg1: *mut __gmp_randstate_struct);
}
extern "C" {
    pub fn __gmp_urandomb_ui(
        arg1: *mut __gmp_randstate_struct,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmp_urandomm_ui(
        arg1: *mut __gmp_randstate_struct,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmp_asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_snprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_realloc(arg1: mpz_ptr, arg2: mp_size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __gmpz_abs(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_add(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_add_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_addmul(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_addmul_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_and(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_array_init(arg1: mpz_ptr, arg2: mp_size_t, arg3: mp_size_t);
}
extern "C" {
    pub fn __gmpz_bin_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_bin_uiui(
        arg1: mpz_ptr,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __gmpz_cdiv_q(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_cdiv_q_2exp(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_cdiv_q_ui(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_cdiv_qr(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_srcptr, arg4: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_cdiv_qr_ui(
        arg1: mpz_ptr,
        arg2: mpz_ptr,
        arg3: mpz_srcptr,
        arg4: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_cdiv_r(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_cdiv_r_2exp(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_cdiv_r_ui(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_cdiv_ui(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_clear(arg1: mpz_ptr);
}
extern "C" {
    pub fn __gmpz_clears(arg1: mpz_ptr, ...);
}
extern "C" {
    pub fn __gmpz_clrbit(arg1: mpz_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_cmp(arg1: mpz_srcptr, arg2: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmp_d(arg1: mpz_srcptr, arg2: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmp_si(arg1: mpz_srcptr, arg2: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmp_ui(arg1: mpz_srcptr, arg2: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmpabs(arg1: mpz_srcptr, arg2: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmpabs_d(arg1: mpz_srcptr, arg2: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmpabs_ui(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_com(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_combit(arg1: mpz_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_congruent_p(
        arg1: mpz_srcptr,
        arg2: mpz_srcptr,
        arg3: mpz_srcptr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_congruent_2exp_p(
        arg1: mpz_srcptr,
        arg2: mpz_srcptr,
        arg3: mp_bitcnt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_congruent_ui_p(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_divexact(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_divexact_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_divisible_p(arg1: mpz_srcptr, arg2: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_divisible_ui_p(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_divisible_2exp_p(arg1: mpz_srcptr, arg2: mp_bitcnt_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_dump(arg1: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_export(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut size_t,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
        arg5: ::std::os::raw::c_int,
        arg6: size_t,
        arg7: mpz_srcptr,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __gmpz_fac_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_2fac_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_mfac_uiui(
        arg1: mpz_ptr,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __gmpz_primorial_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_fdiv_q(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_fdiv_q_2exp(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_fdiv_q_ui(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_fdiv_qr(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_srcptr, arg4: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_fdiv_qr_ui(
        arg1: mpz_ptr,
        arg2: mpz_ptr,
        arg3: mpz_srcptr,
        arg4: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_fdiv_r(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_fdiv_r_2exp(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_fdiv_r_ui(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_fdiv_ui(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_fib_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_fib2_ui(arg1: mpz_ptr, arg2: mpz_ptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_fits_sint_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_fits_slong_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_fits_sshort_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_fits_uint_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_fits_ulong_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_fits_ushort_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_gcd(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_gcd_ui(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_gcdext(
        arg1: mpz_ptr,
        arg2: mpz_ptr,
        arg3: mpz_ptr,
        arg4: mpz_srcptr,
        arg5: mpz_srcptr,
    );
}
extern "C" {
    pub fn __gmpz_get_d(arg1: mpz_srcptr) -> f64;
}
extern "C" {
    pub fn __gmpz_get_d_2exp(arg1: *mut ::std::os::raw::c_long, arg2: mpz_srcptr) -> f64;
}
extern "C" {
    pub fn __gmpz_get_si(arg1: mpz_srcptr) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __gmpz_get_str(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: mpz_srcptr,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __gmpz_get_ui(arg1: mpz_srcptr) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_getlimbn(arg1: mpz_srcptr, arg2: mp_size_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpz_hamdist(arg1: mpz_srcptr, arg2: mpz_srcptr) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpz_import(
        arg1: mpz_ptr,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
        arg5: ::std::os::raw::c_int,
        arg6: size_t,
        arg7: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __gmpz_init(arg1: mpz_ptr);
}
extern "C" {
    pub fn __gmpz_init2(arg1: mpz_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_inits(arg1: mpz_ptr, ...);
}
extern "C" {
    pub fn __gmpz_init_set(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_init_set_d(arg1: mpz_ptr, arg2: f64);
}
extern "C" {
    pub fn __gmpz_init_set_si(arg1: mpz_ptr, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn __gmpz_init_set_str(
        arg1: mpz_ptr,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_init_set_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_invert(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: mpz_srcptr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_ior(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_jacobi(arg1: mpz_srcptr, arg2: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_kronecker_si(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_kronecker_ui(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_si_kronecker(
        arg1: ::std::os::raw::c_long,
        arg2: mpz_srcptr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_ui_kronecker(
        arg1: ::std::os::raw::c_ulong,
        arg2: mpz_srcptr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_lcm(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_lcm_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_lucnum_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_lucnum2_ui(arg1: mpz_ptr, arg2: mpz_ptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_millerrabin(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_mod(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_mul(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_mul_2exp(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_mul_si(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_long);
}
extern "C" {
    pub fn __gmpz_mul_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_neg(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_nextprime(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_perfect_power_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_perfect_square_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_popcount(arg1: mpz_srcptr) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpz_pow_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_powm(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr, arg4: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_powm_sec(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr, arg4: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_powm_ui(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
        arg4: mpz_srcptr,
    );
}
extern "C" {
    pub fn __gmpz_probab_prime_p(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_random(arg1: mpz_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpz_random2(arg1: mpz_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpz_realloc2(arg1: mpz_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_remove(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpz_root(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_rootrem(
        arg1: mpz_ptr,
        arg2: mpz_ptr,
        arg3: mpz_srcptr,
        arg4: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __gmpz_rrandomb(arg1: mpz_ptr, arg2: *mut __gmp_randstate_struct, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_scan0(arg1: mpz_srcptr, arg2: mp_bitcnt_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpz_scan1(arg1: mpz_srcptr, arg2: mp_bitcnt_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpz_set(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_set_d(arg1: mpz_ptr, arg2: f64);
}
extern "C" {
    pub fn __gmpz_set_f(arg1: mpz_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpz_set_q(arg1: mpz_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpz_set_si(arg1: mpz_ptr, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn __gmpz_set_str(
        arg1: mpz_ptr,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_set_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_setbit(arg1: mpz_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_size(arg1: mpz_srcptr) -> size_t;
}
extern "C" {
    pub fn __gmpz_sizeinbase(arg1: mpz_srcptr, arg2: ::std::os::raw::c_int) -> size_t;
}
extern "C" {
    pub fn __gmpz_sqrt(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_sqrtrem(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_sub(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_sub_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_ui_sub(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_submul(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_submul_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_swap(arg1: mpz_ptr, arg2: mpz_ptr);
}
extern "C" {
    pub fn __gmpz_tdiv_ui(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_tdiv_q(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_tdiv_q_2exp(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_tdiv_q_ui(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_tdiv_qr(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_srcptr, arg4: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_tdiv_qr_ui(
        arg1: mpz_ptr,
        arg2: mpz_ptr,
        arg3: mpz_srcptr,
        arg4: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_tdiv_r(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_tdiv_r_2exp(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_tdiv_r_ui(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_tstbit(arg1: mpz_srcptr, arg2: mp_bitcnt_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_ui_pow_ui(
        arg1: mpz_ptr,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __gmpz_urandomb(arg1: mpz_ptr, arg2: *mut __gmp_randstate_struct, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_urandomm(arg1: mpz_ptr, arg2: *mut __gmp_randstate_struct, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_xor(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_limbs_read(arg1: mpz_srcptr) -> mp_srcptr;
}
extern "C" {
    pub fn __gmpz_limbs_write(arg1: mpz_ptr, arg2: mp_size_t) -> mp_ptr;
}
extern "C" {
    pub fn __gmpz_limbs_modify(arg1: mpz_ptr, arg2: mp_size_t) -> mp_ptr;
}
extern "C" {
    pub fn __gmpz_limbs_finish(arg1: mpz_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpz_roinit_n(arg1: mpz_ptr, arg2: mp_srcptr, arg3: mp_size_t) -> mpz_srcptr;
}
extern "C" {
    pub fn __gmpq_abs(arg1: mpq_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_add(arg1: mpq_ptr, arg2: mpq_srcptr, arg3: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_canonicalize(arg1: mpq_ptr);
}
extern "C" {
    pub fn __gmpq_clear(arg1: mpq_ptr);
}
extern "C" {
    pub fn __gmpq_clears(arg1: mpq_ptr, ...);
}
extern "C" {
    pub fn __gmpq_cmp(arg1: mpq_srcptr, arg2: mpq_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_cmp_si(
        arg1: mpq_srcptr,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_cmp_ui(
        arg1: mpq_srcptr,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_cmp_z(arg1: mpq_srcptr, arg2: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_div(arg1: mpq_ptr, arg2: mpq_srcptr, arg3: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_div_2exp(arg1: mpq_ptr, arg2: mpq_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpq_equal(arg1: mpq_srcptr, arg2: mpq_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_get_num(arg1: mpz_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_get_den(arg1: mpz_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_get_d(arg1: mpq_srcptr) -> f64;
}
extern "C" {
    pub fn __gmpq_get_str(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: mpq_srcptr,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __gmpq_init(arg1: mpq_ptr);
}
extern "C" {
    pub fn __gmpq_inits(arg1: mpq_ptr, ...);
}
extern "C" {
    pub fn __gmpq_inv(arg1: mpq_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_mul(arg1: mpq_ptr, arg2: mpq_srcptr, arg3: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_mul_2exp(arg1: mpq_ptr, arg2: mpq_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpq_neg(arg1: mpq_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_set(arg1: mpq_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_set_d(arg1: mpq_ptr, arg2: f64);
}
extern "C" {
    pub fn __gmpq_set_den(arg1: mpq_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpq_set_f(arg1: mpq_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpq_set_num(arg1: mpq_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpq_set_si(
        arg1: mpq_ptr,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __gmpq_set_str(
        arg1: mpq_ptr,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_set_ui(
        arg1: mpq_ptr,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __gmpq_set_z(arg1: mpq_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpq_sub(arg1: mpq_ptr, arg2: mpq_srcptr, arg3: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_swap(arg1: mpq_ptr, arg2: mpq_ptr);
}
extern "C" {
    pub fn __gmpf_abs(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_add(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_add_ui(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_ceil(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_clear(arg1: mpf_ptr);
}
extern "C" {
    pub fn __gmpf_clears(arg1: mpf_ptr, ...);
}
extern "C" {
    pub fn __gmpf_cmp(arg1: mpf_srcptr, arg2: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_cmp_z(arg1: mpf_srcptr, arg2: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_cmp_d(arg1: mpf_srcptr, arg2: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_cmp_si(arg1: mpf_srcptr, arg2: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_cmp_ui(arg1: mpf_srcptr, arg2: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_div(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_div_2exp(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_div_ui(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_dump(arg1: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_eq(
        arg1: mpf_srcptr,
        arg2: mpf_srcptr,
        arg3: mp_bitcnt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_sint_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_slong_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_sshort_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_uint_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_ulong_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_ushort_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_floor(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_get_d(arg1: mpf_srcptr) -> f64;
}
extern "C" {
    pub fn __gmpf_get_d_2exp(arg1: *mut ::std::os::raw::c_long, arg2: mpf_srcptr) -> f64;
}
extern "C" {
    pub fn __gmpf_get_default_prec() -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpf_get_prec(arg1: mpf_srcptr) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpf_get_si(arg1: mpf_srcptr) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __gmpf_get_str(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut mp_exp_t,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
        arg5: mpf_srcptr,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __gmpf_get_ui(arg1: mpf_srcptr) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpf_init(arg1: mpf_ptr);
}
extern "C" {
    pub fn __gmpf_init2(arg1: mpf_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_inits(arg1: mpf_ptr, ...);
}
extern "C" {
    pub fn __gmpf_init_set(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_init_set_d(arg1: mpf_ptr, arg2: f64);
}
extern "C" {
    pub fn __gmpf_init_set_si(arg1: mpf_ptr, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn __gmpf_init_set_str(
        arg1: mpf_ptr,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_init_set_ui(arg1: mpf_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_integer_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_mul(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_mul_2exp(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_mul_ui(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_neg(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_pow_ui(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_random2(arg1: mpf_ptr, arg2: mp_size_t, arg3: mp_exp_t);
}
extern "C" {
    pub fn __gmpf_reldiff(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_set(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_set_d(arg1: mpf_ptr, arg2: f64);
}
extern "C" {
    pub fn __gmpf_set_default_prec(arg1: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_set_prec(arg1: mpf_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_set_prec_raw(arg1: mpf_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_set_q(arg1: mpf_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpf_set_si(arg1: mpf_ptr, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn __gmpf_set_str(
        arg1: mpf_ptr,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_set_ui(arg1: mpf_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_set_z(arg1: mpf_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpf_size(arg1: mpf_srcptr) -> size_t;
}
extern "C" {
    pub fn __gmpf_sqrt(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_sqrt_ui(arg1: mpf_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_sub(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_sub_ui(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_swap(arg1: mpf_ptr, arg2: mpf_ptr);
}
extern "C" {
    pub fn __gmpf_trunc(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_ui_div(arg1: mpf_ptr, arg2: ::std::os::raw::c_ulong, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_ui_sub(arg1: mpf_ptr, arg2: ::std::os::raw::c_ulong, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_urandomb(
        arg1: *mut __mpf_struct,
        arg2: *mut __gmp_randstate_struct,
        arg3: mp_bitcnt_t,
    );
}
extern "C" {
    pub fn __gmpn_add(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_srcptr,
        arg5: mp_size_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_add_1(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_add_n(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_srcptr,
        arg4: mp_size_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_addmul_1(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_cmp(arg1: mp_srcptr, arg2: mp_srcptr, arg3: mp_size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpn_zero_p(arg1: mp_srcptr, arg2: mp_size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpn_divexact_1(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t, arg4: mp_limb_t);
}
extern "C" {
    pub fn __gmpn_divexact_by3c(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_divrem(
        arg1: mp_ptr,
        arg2: mp_size_t,
        arg3: mp_ptr,
        arg4: mp_size_t,
        arg5: mp_srcptr,
        arg6: mp_size_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_divrem_1(
        arg1: mp_ptr,
        arg2: mp_size_t,
        arg3: mp_srcptr,
        arg4: mp_size_t,
        arg5: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_divrem_2(
        arg1: mp_ptr,
        arg2: mp_size_t,
        arg3: mp_ptr,
        arg4: mp_size_t,
        arg5: mp_srcptr,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_div_qr_1(
        arg1: mp_ptr,
        arg2: *mut mp_limb_t,
        arg3: mp_srcptr,
        arg4: mp_size_t,
        arg5: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_div_qr_2(
        arg1: mp_ptr,
        arg2: mp_ptr,
        arg3: mp_srcptr,
        arg4: mp_size_t,
        arg5: mp_srcptr,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_gcd(
        arg1: mp_ptr,
        arg2: mp_ptr,
        arg3: mp_size_t,
        arg4: mp_ptr,
        arg5: mp_size_t,
    ) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_gcd_11(arg1: mp_limb_t, arg2: mp_limb_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_gcd_1(arg1: mp_srcptr, arg2: mp_size_t, arg3: mp_limb_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_gcdext_1(
        arg1: *mut mp_limb_signed_t,
        arg2: *mut mp_limb_signed_t,
        arg3: mp_limb_t,
        arg4: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_gcdext(
        arg1: mp_ptr,
        arg2: mp_ptr,
        arg3: *mut mp_size_t,
        arg4: mp_ptr,
        arg5: mp_size_t,
        arg6: mp_ptr,
        arg7: mp_size_t,
    ) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_get_str(
        arg1: *mut ::std::os::raw::c_uchar,
        arg2: ::std::os::raw::c_int,
        arg3: mp_ptr,
        arg4: mp_size_t,
    ) -> size_t;
}
extern "C" {
    pub fn __gmpn_hamdist(arg1: mp_srcptr, arg2: mp_srcptr, arg3: mp_size_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpn_lshift(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: ::std::os::raw::c_uint,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_mod_1(arg1: mp_srcptr, arg2: mp_size_t, arg3: mp_limb_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_mul(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_srcptr,
        arg5: mp_size_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_mul_1(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_mul_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_sqr(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t);
}
extern "C" {
    pub fn __gmpn_neg(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_com(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t);
}
extern "C" {
    pub fn __gmpn_perfect_square_p(arg1: mp_srcptr, arg2: mp_size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpn_perfect_power_p(arg1: mp_srcptr, arg2: mp_size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpn_popcount(arg1: mp_srcptr, arg2: mp_size_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpn_pow_1(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_limb_t,
        arg5: mp_ptr,
    ) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_preinv_mod_1(
        arg1: mp_srcptr,
        arg2: mp_size_t,
        arg3: mp_limb_t,
        arg4: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_random(arg1: mp_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpn_random2(arg1: mp_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpn_rshift(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: ::std::os::raw::c_uint,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_scan0(arg1: mp_srcptr, arg2: mp_bitcnt_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpn_scan1(arg1: mp_srcptr, arg2: mp_bitcnt_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpn_set_str(
        arg1: mp_ptr,
        arg2: *const ::std::os::raw::c_uchar,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
    ) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sizeinbase(
        arg1: mp_srcptr,
        arg2: mp_size_t,
        arg3: ::std::os::raw::c_int,
    ) -> size_t;
}
extern "C" {
    pub fn __gmpn_sqrtrem(
        arg1: mp_ptr,
        arg2: mp_ptr,
        arg3: mp_srcptr,
        arg4: mp_size_t,
    ) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sub(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_srcptr,
        arg5: mp_size_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_sub_1(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_sub_n(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_srcptr,
        arg4: mp_size_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_submul_1(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_tdiv_qr(
        arg1: mp_ptr,
        arg2: mp_ptr,
        arg3: mp_size_t,
        arg4: mp_srcptr,
        arg5: mp_size_t,
        arg6: mp_srcptr,
        arg7: mp_size_t,
    );
}
extern "C" {
    pub fn __gmpn_and_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_andn_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_nand_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_ior_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_iorn_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_nior_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_xor_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_xnor_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_copyi(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t);
}
extern "C" {
    pub fn __gmpn_copyd(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t);
}
extern "C" {
    pub fn __gmpn_zero(arg1: mp_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpn_cnd_add_n(
        arg1: mp_limb_t,
        arg2: mp_ptr,
        arg3: mp_srcptr,
        arg4: mp_srcptr,
        arg5: mp_size_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_cnd_sub_n(
        arg1: mp_limb_t,
        arg2: mp_ptr,
        arg3: mp_srcptr,
        arg4: mp_srcptr,
        arg5: mp_size_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_sec_add_1(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_limb_t,
        arg5: mp_ptr,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_sec_add_1_itch(arg1: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_sub_1(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_limb_t,
        arg5: mp_ptr,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_sec_sub_1_itch(arg1: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_cnd_swap(
        arg1: mp_limb_t,
        arg2: *mut mp_limb_t,
        arg3: *mut mp_limb_t,
        arg4: mp_size_t,
    );
}
extern "C" {
    pub fn __gmpn_sec_mul(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_srcptr,
        arg5: mp_size_t,
        arg6: mp_ptr,
    );
}
extern "C" {
    pub fn __gmpn_sec_mul_itch(arg1: mp_size_t, arg2: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_sqr(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t, arg4: mp_ptr);
}
extern "C" {
    pub fn __gmpn_sec_sqr_itch(arg1: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_powm(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_srcptr,
        arg5: mp_bitcnt_t,
        arg6: mp_srcptr,
        arg7: mp_size_t,
        arg8: mp_ptr,
    );
}
extern "C" {
    pub fn __gmpn_sec_powm_itch(arg1: mp_size_t, arg2: mp_bitcnt_t, arg3: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_tabselect(
        arg1: *mut mp_limb_t,
        arg2: *const mp_limb_t,
        arg3: mp_size_t,
        arg4: mp_size_t,
        arg5: mp_size_t,
    );
}
extern "C" {
    pub fn __gmpn_sec_div_qr(
        arg1: mp_ptr,
        arg2: mp_ptr,
        arg3: mp_size_t,
        arg4: mp_srcptr,
        arg5: mp_size_t,
        arg6: mp_ptr,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_sec_div_qr_itch(arg1: mp_size_t, arg2: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_div_r(
        arg1: mp_ptr,
        arg2: mp_size_t,
        arg3: mp_srcptr,
        arg4: mp_size_t,
        arg5: mp_ptr,
    );
}
extern "C" {
    pub fn __gmpn_sec_div_r_itch(arg1: mp_size_t, arg2: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_invert(
        arg1: mp_ptr,
        arg2: mp_ptr,
        arg3: mp_srcptr,
        arg4: mp_size_t,
        arg5: mp_bitcnt_t,
        arg6: mp_ptr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpn_sec_invert_itch(arg1: mp_size_t) -> mp_size_t;
}
pub const GMP_ERROR_NONE: ::std::os::raw::c_uint = 0;
pub const GMP_ERROR_UNSUPPORTED_ARGUMENT: ::std::os::raw::c_uint = 1;
pub const GMP_ERROR_DIVISION_BY_ZERO: ::std::os::raw::c_uint = 2;
pub const GMP_ERROR_SQRT_OF_NEGATIVE: ::std::os::raw::c_uint = 4;
pub const GMP_ERROR_INVALID_ARGUMENT: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
extern "C" {
    pub fn gettimeofday(
        __tv: *mut timeval,
        __tz: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub type __itimer_which_t = ::std::os::raw::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
pub type clock_t = __clock_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__atomic_wide_counter__bindgen_ty_1>())).__low as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__atomic_wide_counter__bindgen_ty_1>())).__high as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__atomic_wide_counter>())).__value64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__atomic_wide_counter>())).__value32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wseq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__once_flag>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type scm_t_int8 = i8;
pub type scm_t_uint8 = u8;
pub type scm_t_int16 = i16;
pub type scm_t_uint16 = u16;
pub type scm_t_int32 = i32;
pub type scm_t_uint32 = u32;
pub type scm_t_intmax = intmax_t;
pub type scm_t_uintmax = uintmax_t;
pub type scm_t_intptr = isize;
pub type scm_t_uintptr = usize;
pub type scm_t_int64 = i64;
pub type scm_t_uint64 = u64;
pub type scm_t_ptrdiff = isize;
pub type scm_t_timespec = timespec;
pub type scm_t_off = scm_t_int64;
pub type scm_t_signed_bits = scm_t_intptr;
pub type scm_t_bits = scm_t_uintptr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_unused_struct {
    pub scm_unused_field: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_scm_unused_struct() {
    assert_eq!(
        ::std::mem::size_of::<scm_unused_struct>(),
        1usize,
        concat!("Size of: ", stringify!(scm_unused_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_unused_struct>(),
        1usize,
        concat!("Alignment of ", stringify!(scm_unused_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<scm_unused_struct>())).scm_unused_field as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_unused_struct),
            "::",
            stringify!(scm_unused_field)
        )
    );
}
pub type SCM = *mut scm_unused_struct;
pub const scm_tc8_tags_scm_tc8_flag: scm_tc8_tags = 4;
pub const scm_tc8_tags_scm_tc8_char: scm_tc8_tags = 12;
pub const scm_tc8_tags_scm_tc8_unused_0: scm_tc8_tags = 20;
pub const scm_tc8_tags_scm_tc8_unused_1: scm_tc8_tags = 28;
pub type scm_tc8_tags = ::std::os::raw::c_uint;
pub type scm_t_subr = *mut ::std::os::raw::c_void;
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__jmpbuf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__mask_was_saved as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__saved_mask as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub type jmp_buf = [__jmp_buf_tag; 1usize];
extern "C" {
    pub fn setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
pub type sigjmp_buf = [__jmp_buf_tag; 1usize];
extern "C" {
    pub fn siglongjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
pub type SCM_STACKITEM = ::std::os::raw::c_long;
extern "C" {
    pub fn scm_async_tick();
}
extern "C" {
    pub fn scm_call_generic_0(gf: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_generic_1(gf: SCM, a1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_generic_2(gf: SCM, a1: SCM, a2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_apply_generic(gf: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_acons(w: SCM, x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sloppy_assq(x: SCM, alist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sloppy_assv(x: SCM, alist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sloppy_assoc(x: SCM, alist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assq(x: SCM, alist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assv(x: SCM, alist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assoc(x: SCM, alist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assq_ref(alist: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assv_ref(alist: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assoc_ref(alist: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assq_set_x(alist: SCM, key: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assv_set_x(alist: SCM, key: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assoc_set_x(alist: SCM, key: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assq_remove_x(alist: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assv_remove_x(alist: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assoc_remove_x(alist: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_alist();
}
extern "C" {
    pub fn scm_make_arbiter(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_try_arbiter(arb: SCM) -> SCM;
}
extern "C" {
    pub fn scm_release_arbiter(arb: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_arbiters();
}
extern "C" {
    pub static mut scm_system_error_key: SCM;
}
extern "C" {
    pub static mut scm_num_overflow_key: SCM;
}
extern "C" {
    pub static mut scm_out_of_range_key: SCM;
}
extern "C" {
    pub static mut scm_args_number_key: SCM;
}
extern "C" {
    pub static mut scm_arg_type_key: SCM;
}
extern "C" {
    pub static mut scm_memory_alloc_key: SCM;
}
extern "C" {
    pub static mut scm_misc_error_key: SCM;
}
extern "C" {
    pub fn scm_error(
        key: SCM,
        subr: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
        args: SCM,
        rest: SCM,
    );
}
extern "C" {
    pub fn scm_error_scm(key: SCM, subr: SCM, message: SCM, args: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_strerror(err: SCM) -> SCM;
}
extern "C" {
    pub fn scm_syserror(subr: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_syserror_msg(
        subr: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
        args: SCM,
        eno: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn scm_num_overflow(subr: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_out_of_range(subr: *const ::std::os::raw::c_char, bad_value: SCM);
}
extern "C" {
    pub fn scm_out_of_range_pos(subr: *const ::std::os::raw::c_char, bad_value: SCM, pos: SCM);
}
extern "C" {
    pub fn scm_wrong_num_args(proc_: SCM);
}
extern "C" {
    pub fn scm_error_num_args_subr(subr: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_wrong_type_arg(
        subr: *const ::std::os::raw::c_char,
        pos: ::std::os::raw::c_int,
        bad_value: SCM,
    );
}
extern "C" {
    pub fn scm_i_wrong_type_arg_symbol(symbol: SCM, pos: ::std::os::raw::c_int, bad_value: SCM);
}
extern "C" {
    pub fn scm_wrong_type_arg_msg(
        subr: *const ::std::os::raw::c_char,
        pos: ::std::os::raw::c_int,
        bad_value: SCM,
        sz: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn scm_memory_error(subr: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_misc_error(
        subr: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
        args: SCM,
    );
}
extern "C" {
    pub fn scm_init_error();
}
pub type scm_t_wchar = scm_t_int32;
extern "C" {
    pub fn scm_char_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_eq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_less_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_leq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_gr_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_geq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_ci_eq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_ci_less_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_ci_leq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_ci_gr_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_ci_geq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_alphabetic_p(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_numeric_p(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_whitespace_p(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_upper_case_p(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_lower_case_p(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_is_both_p(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_to_integer(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_integer_to_char(n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_upcase(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_downcase(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_titlecase(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_general_category(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_upcase(c: scm_t_wchar) -> scm_t_wchar;
}
extern "C" {
    pub fn scm_c_downcase(c: scm_t_wchar) -> scm_t_wchar;
}
extern "C" {
    pub fn scm_c_titlecase(c: scm_t_wchar) -> scm_t_wchar;
}
extern "C" {
    pub fn scm_i_charname(chr: SCM) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_charname_to_char(
        charname: *const ::std::os::raw::c_char,
        charname_len: size_t,
    ) -> SCM;
}
extern "C" {
    pub fn scm_init_chars();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_option {
    pub type_: ::std::os::raw::c_uint,
    pub name: *const ::std::os::raw::c_char,
    pub val: scm_t_bits,
    pub doc: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_scm_t_option() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_option>(),
        32usize,
        concat!("Size of: ", stringify!(scm_t_option))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_option>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_option))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_option>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_option),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_option>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_option),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_option>())).val as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_option),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_option>())).doc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_option),
            "::",
            stringify!(doc)
        )
    );
}
extern "C" {
    pub fn scm_options_try(
        args: SCM,
        options: *mut scm_t_option,
        s: *const ::std::os::raw::c_char,
        dry_run: ::std::os::raw::c_int,
    ) -> SCM;
}
extern "C" {
    pub fn scm_options(
        arg1: SCM,
        arg2: *mut scm_t_option,
        arg3: *const ::std::os::raw::c_char,
    ) -> SCM;
}
extern "C" {
    pub fn scm_init_opts(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: SCM) -> SCM>,
        arg2: *mut scm_t_option,
    );
}
extern "C" {
    pub fn scm_init_options();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_print_state {
    pub handle: SCM,
    pub revealed: ::std::os::raw::c_int,
    pub writingp: ::std::os::raw::c_ulong,
    pub fancyp: ::std::os::raw::c_ulong,
    pub level: ::std::os::raw::c_ulong,
    pub length: ::std::os::raw::c_ulong,
    pub hot_ref: SCM,
    pub list_offset: ::std::os::raw::c_ulong,
    pub top: ::std::os::raw::c_ulong,
    pub ceiling: ::std::os::raw::c_ulong,
    pub ref_vect: SCM,
    pub highlight_objects: SCM,
}
#[test]
fn bindgen_test_layout_scm_print_state() {
    assert_eq!(
        ::std::mem::size_of::<scm_print_state>(),
        96usize,
        concat!("Size of: ", stringify!(scm_print_state))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_print_state>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_print_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_print_state>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_print_state),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_print_state>())).revealed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_print_state),
            "::",
            stringify!(revealed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_print_state>())).writingp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_print_state),
            "::",
            stringify!(writingp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_print_state>())).fancyp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_print_state),
            "::",
            stringify!(fancyp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_print_state>())).level as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_print_state),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_print_state>())).length as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_print_state),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_print_state>())).hot_ref as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_print_state),
            "::",
            stringify!(hot_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_print_state>())).list_offset as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_print_state),
            "::",
            stringify!(list_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_print_state>())).top as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_print_state),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_print_state>())).ceiling as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_print_state),
            "::",
            stringify!(ceiling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_print_state>())).ref_vect as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_print_state),
            "::",
            stringify!(ref_vect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<scm_print_state>())).highlight_objects as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_print_state),
            "::",
            stringify!(highlight_objects)
        )
    );
}
extern "C" {
    pub static mut scm_print_state_vtable: SCM;
}
extern "C" {
    pub static mut scm_tc16_port_with_ps: scm_t_bits;
}
extern "C" {
    pub fn scm_print_options(setting: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_print_state() -> SCM;
}
extern "C" {
    pub fn scm_free_print_state(print_state: SCM);
}
extern "C" {
    pub fn scm_i_port_with_print_state(port: SCM, print_state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_display_substring(str_: SCM, start: size_t, end: size_t, port: SCM);
}
extern "C" {
    pub fn scm_intprint(n: scm_t_intmax, radix: ::std::os::raw::c_int, port: SCM);
}
extern "C" {
    pub fn scm_uintprint(n: scm_t_uintmax, radix: ::std::os::raw::c_int, port: SCM);
}
extern "C" {
    pub fn scm_ipruk(hdr: *mut ::std::os::raw::c_char, ptr: SCM, port: SCM);
}
extern "C" {
    pub fn scm_iprlist(
        hdr: *mut ::std::os::raw::c_char,
        exp: SCM,
        tlr: ::std::os::raw::c_int,
        port: SCM,
        pstate: *mut scm_print_state,
    );
}
extern "C" {
    pub fn scm_i_print_symbol_name(sym: SCM, port: SCM);
}
extern "C" {
    pub fn scm_print_symbol_name(str_: *const ::std::os::raw::c_char, len: size_t, port: SCM);
}
extern "C" {
    pub fn scm_prin1(exp: SCM, port: SCM, writingp: ::std::os::raw::c_int);
}
extern "C" {
    pub fn scm_iprin1(exp: SCM, port: SCM, pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_write(obj: SCM, port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_display(obj: SCM, port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_simple_format(port: SCM, message: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_newline(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_write_char(chr: SCM, port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_printer_apply(proc_: SCM, exp: SCM, port: SCM, arg1: *mut scm_print_state) -> SCM;
}
extern "C" {
    pub fn scm_port_with_print_state(port: SCM, pstate: SCM) -> SCM;
}
extern "C" {
    pub fn scm_get_print_state(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_valid_oport_value_p(val: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_init_print();
}
pub type scm_t_inum = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_double {
    pub type_: SCM,
    pub pad: SCM,
    pub real: f64,
}
#[test]
fn bindgen_test_layout_scm_t_double() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_double>(),
        24usize,
        concat!("Size of: ", stringify!(scm_t_double))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_double>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_double))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_double>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_double),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_double>())).pad as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_double),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_double>())).real as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_double),
            "::",
            stringify!(real)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_complex {
    pub type_: SCM,
    pub pad: SCM,
    pub real: f64,
    pub imag: f64,
}
#[test]
fn bindgen_test_layout_scm_t_complex() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_complex>(),
        32usize,
        concat!("Size of: ", stringify!(scm_t_complex))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_complex>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_complex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_complex>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_complex),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_complex>())).pad as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_complex),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_complex>())).real as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_complex),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_complex>())).imag as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_complex),
            "::",
            stringify!(imag)
        )
    );
}
extern "C" {
    pub fn scm_exact_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_exact(x: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_odd_p(n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_even_p(n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_finite_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inf_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_nan_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inf() -> SCM;
}
extern "C" {
    pub fn scm_nan() -> SCM;
}
extern "C" {
    pub fn scm_abs(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_quotient(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_remainder(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_modulo(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_euclidean_divide(x: SCM, y: SCM, q: *mut SCM, r: *mut SCM);
}
extern "C" {
    pub fn scm_euclidean_quotient(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_euclidean_remainder(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_floor_divide(x: SCM, y: SCM, q: *mut SCM, r: *mut SCM);
}
extern "C" {
    pub fn scm_floor_quotient(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_floor_remainder(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ceiling_divide(x: SCM, y: SCM, q: *mut SCM, r: *mut SCM);
}
extern "C" {
    pub fn scm_ceiling_quotient(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ceiling_remainder(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_truncate_divide(x: SCM, y: SCM, q: *mut SCM, r: *mut SCM);
}
extern "C" {
    pub fn scm_truncate_quotient(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_truncate_remainder(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_centered_divide(x: SCM, y: SCM, q: *mut SCM, r: *mut SCM);
}
extern "C" {
    pub fn scm_centered_quotient(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_centered_remainder(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_round_divide(x: SCM, y: SCM, q: *mut SCM, r: *mut SCM);
}
extern "C" {
    pub fn scm_round_quotient(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_round_remainder(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gcd(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lcm(n1: SCM, n2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_logand(n1: SCM, n2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_logior(n1: SCM, n2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_logxor(n1: SCM, n2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_logtest(n1: SCM, n2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_logbit_p(n1: SCM, n2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lognot(n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_modulo_expt(n: SCM, k: SCM, m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_integer_expt(z1: SCM, z2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ash(n: SCM, count: SCM) -> SCM;
}
extern "C" {
    pub fn scm_round_ash(n: SCM, count: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bit_extract(n: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_logcount(n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_integer_length(n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_euclidean_divide(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_floor_divide(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_ceiling_divide(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_truncate_divide(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_centered_divide(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_round_divide(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_gcd(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_lcm(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_logand(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_logior(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_logxor(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_iint2str(
        num: scm_t_intmax,
        rad: ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    pub fn scm_iuint2str(
        num: scm_t_uintmax,
        rad: ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    pub fn scm_number_to_string(x: SCM, radix: SCM) -> SCM;
}
extern "C" {
    pub fn scm_print_real(
        sexp: SCM,
        port: SCM,
        pstate: *mut scm_print_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_print_complex(
        sexp: SCM,
        port: SCM,
        pstate: *mut scm_print_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_bigprint(exp: SCM, port: SCM, pstate: *mut scm_print_state)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_locale_stringn_to_number(
        mem: *const ::std::os::raw::c_char,
        len: size_t,
        radix: ::std::os::raw::c_uint,
    ) -> SCM;
}
extern "C" {
    pub fn scm_i_string_to_number(str_: SCM, radix: ::std::os::raw::c_uint) -> SCM;
}
extern "C" {
    pub fn scm_string_to_number(str_: SCM, radix: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bigequal(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_real_equalp(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_complex_equalp(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_number_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_complex_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_real_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_rational_p(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_integer_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_exact_integer_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inexact_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_inexact(x: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_num_eq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_less_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gr_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_leq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_geq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_zero_p(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_positive_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_negative_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_max(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_min(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sum(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_oneplus(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_difference(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_oneminus(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_product(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_divide(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_floor(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ceiling(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_truncate(x: f64) -> f64;
}
extern "C" {
    pub fn scm_c_round(x: f64) -> f64;
}
extern "C" {
    pub fn scm_truncate_number(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_round_number(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_expt(z1: SCM, z2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sin(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cos(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_tan(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sinh(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cosh(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_tanh(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_asin(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_acos(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_atan(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_asinh(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_acosh(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_atanh(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_rectangular(z1: SCM, z2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_polar(z1: SCM, z2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_real_part(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_imag_part(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_magnitude(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_angle(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_exact_to_inexact(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inexact_to_exact(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_trunc(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_log(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_log10(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_exp(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sqrt(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_exact_integer_sqrt(k: SCM, s: *mut SCM, r: *mut SCM);
}
extern "C" {
    pub fn scm_i_min(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_max(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_sum(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_difference(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_product(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_divide(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_exact_integer_sqrt(k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_mkbig() -> SCM;
}
extern "C" {
    pub fn scm_i_normbig(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_bigcmp(a: SCM, b: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_dbl2big(d: f64) -> SCM;
}
extern "C" {
    pub fn scm_i_dbl2num(d: f64) -> SCM;
}
extern "C" {
    pub fn scm_i_big2dbl(b: SCM) -> f64;
}
extern "C" {
    pub fn scm_i_long2big(n: ::std::os::raw::c_long) -> SCM;
}
extern "C" {
    pub fn scm_i_ulong2big(n: ::std::os::raw::c_ulong) -> SCM;
}
extern "C" {
    pub fn scm_i_clonebig(src_big: SCM, same_sign_p: ::std::os::raw::c_int) -> SCM;
}
extern "C" {
    pub fn scm_rationalize(x: SCM, err: SCM) -> SCM;
}
extern "C" {
    pub fn scm_numerator(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_denominator(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_fraction2double(z: SCM) -> f64;
}
extern "C" {
    pub fn scm_i_fraction_equalp(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_print_fraction(
        sexp: SCM,
        port: SCM,
        pstate: *mut scm_print_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_print_double(val: f64, port: SCM);
}
extern "C" {
    pub fn scm_i_print_complex(real: f64, imag: f64, port: SCM);
}
extern "C" {
    pub fn scm_is_integer(val: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_is_exact_integer(val: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_is_signed_integer(
        val: SCM,
        min: scm_t_intmax,
        max: scm_t_intmax,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_is_unsigned_integer(
        val: SCM,
        min: scm_t_uintmax,
        max: scm_t_uintmax,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_from_signed_integer(val: scm_t_intmax) -> SCM;
}
extern "C" {
    pub fn scm_from_unsigned_integer(val: scm_t_uintmax) -> SCM;
}
extern "C" {
    pub fn scm_to_signed_integer(val: SCM, min: scm_t_intmax, max: scm_t_intmax) -> scm_t_intmax;
}
extern "C" {
    pub fn scm_to_unsigned_integer(
        val: SCM,
        min: scm_t_uintmax,
        max: scm_t_uintmax,
    ) -> scm_t_uintmax;
}
extern "C" {
    pub fn scm_to_int8(x: SCM) -> scm_t_int8;
}
extern "C" {
    pub fn scm_from_int8(x: scm_t_int8) -> SCM;
}
extern "C" {
    pub fn scm_to_uint8(x: SCM) -> scm_t_uint8;
}
extern "C" {
    pub fn scm_from_uint8(x: scm_t_uint8) -> SCM;
}
extern "C" {
    pub fn scm_to_int16(x: SCM) -> scm_t_int16;
}
extern "C" {
    pub fn scm_from_int16(x: scm_t_int16) -> SCM;
}
extern "C" {
    pub fn scm_to_uint16(x: SCM) -> scm_t_uint16;
}
extern "C" {
    pub fn scm_from_uint16(x: scm_t_uint16) -> SCM;
}
extern "C" {
    pub fn scm_to_int32(x: SCM) -> scm_t_int32;
}
extern "C" {
    pub fn scm_from_int32(x: scm_t_int32) -> SCM;
}
extern "C" {
    pub fn scm_to_uint32(x: SCM) -> scm_t_uint32;
}
extern "C" {
    pub fn scm_from_uint32(x: scm_t_uint32) -> SCM;
}
extern "C" {
    pub fn scm_to_wchar(x: SCM) -> scm_t_wchar;
}
extern "C" {
    pub fn scm_from_wchar(x: scm_t_wchar) -> SCM;
}
extern "C" {
    pub fn scm_to_int64(x: SCM) -> scm_t_int64;
}
extern "C" {
    pub fn scm_from_int64(x: scm_t_int64) -> SCM;
}
extern "C" {
    pub fn scm_to_uint64(x: SCM) -> scm_t_uint64;
}
extern "C" {
    pub fn scm_from_uint64(x: scm_t_uint64) -> SCM;
}
extern "C" {
    pub fn scm_to_mpz(x: SCM, rop: *mut __mpz_struct);
}
extern "C" {
    pub fn scm_from_mpz(rop: *mut __mpz_struct) -> SCM;
}
extern "C" {
    pub fn scm_is_real(val: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_is_rational(val: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_to_double(val: SCM) -> f64;
}
extern "C" {
    pub fn scm_from_double(val: f64) -> SCM;
}
extern "C" {
    pub fn scm_is_complex(val: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_make_rectangular(re: f64, im: f64) -> SCM;
}
extern "C" {
    pub fn scm_c_make_polar(mag: f64, ang: f64) -> SCM;
}
extern "C" {
    pub fn scm_c_real_part(z: SCM) -> f64;
}
extern "C" {
    pub fn scm_c_imag_part(z: SCM) -> f64;
}
extern "C" {
    pub fn scm_c_magnitude(z: SCM) -> f64;
}
extern "C" {
    pub fn scm_c_angle(z: SCM) -> f64;
}
extern "C" {
    pub fn scm_is_number(val: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut scm_install_gmp_memory_functions: ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_init_numbers();
}
pub type scm_i_t_array_ref =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut scm_t_array_handle, arg2: size_t) -> SCM>;
pub type scm_i_t_array_set = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut scm_t_array_handle, arg2: size_t, arg3: SCM),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_array_implementation {
    pub tag: scm_t_bits,
    pub mask: scm_t_bits,
    pub vref: scm_i_t_array_ref,
    pub vset: scm_i_t_array_set,
    pub get_handle:
        ::std::option::Option<unsafe extern "C" fn(arg1: SCM, arg2: *mut scm_t_array_handle)>,
}
#[test]
fn bindgen_test_layout_scm_t_array_implementation() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_array_implementation>(),
        40usize,
        concat!("Size of: ", stringify!(scm_t_array_implementation))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_array_implementation>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_array_implementation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_array_implementation>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_implementation),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_array_implementation>())).mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_implementation),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_array_implementation>())).vref as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_implementation),
            "::",
            stringify!(vref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_array_implementation>())).vset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_implementation),
            "::",
            stringify!(vset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<scm_t_array_implementation>())).get_handle as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_implementation),
            "::",
            stringify!(get_handle)
        )
    );
}
extern "C" {
    pub fn scm_i_register_array_implementation(impl_: *mut scm_t_array_implementation);
}
extern "C" {
    pub fn scm_i_array_implementation_for_obj(obj: SCM) -> *mut scm_t_array_implementation;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_array_dim {
    pub lbnd: ssize_t,
    pub ubnd: ssize_t,
    pub inc: ssize_t,
}
#[test]
fn bindgen_test_layout_scm_t_array_dim() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_array_dim>(),
        24usize,
        concat!("Size of: ", stringify!(scm_t_array_dim))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_array_dim>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_array_dim))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_array_dim>())).lbnd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_dim),
            "::",
            stringify!(lbnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_array_dim>())).ubnd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_dim),
            "::",
            stringify!(ubnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_array_dim>())).inc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_dim),
            "::",
            stringify!(inc)
        )
    );
}
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_SCM: scm_t_array_element_type = 0;
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_CHAR: scm_t_array_element_type = 1;
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_BIT: scm_t_array_element_type = 2;
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_VU8: scm_t_array_element_type = 3;
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_U8: scm_t_array_element_type = 4;
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_S8: scm_t_array_element_type = 5;
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_U16: scm_t_array_element_type = 6;
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_S16: scm_t_array_element_type = 7;
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_U32: scm_t_array_element_type = 8;
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_S32: scm_t_array_element_type = 9;
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_U64: scm_t_array_element_type = 10;
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_S64: scm_t_array_element_type = 11;
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_F32: scm_t_array_element_type = 12;
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_F64: scm_t_array_element_type = 13;
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_C32: scm_t_array_element_type = 14;
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_C64: scm_t_array_element_type = 15;
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_LAST: scm_t_array_element_type = 15;
pub type scm_t_array_element_type = ::std::os::raw::c_uint;
extern "C" {
    pub static mut scm_i_array_element_types: [SCM; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_array_handle {
    pub array: SCM,
    pub impl_: *mut scm_t_array_implementation,
    pub base: size_t,
    pub ndims: size_t,
    pub dims: *mut scm_t_array_dim,
    pub dim0: scm_t_array_dim,
    pub element_type: scm_t_array_element_type,
    pub elements: *const ::std::os::raw::c_void,
    pub writable_elements: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_scm_t_array_handle() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_array_handle>(),
        88usize,
        concat!("Size of: ", stringify!(scm_t_array_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_array_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_array_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_array_handle>())).array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_handle),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_array_handle>())).impl_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_handle),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_array_handle>())).base as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_handle),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_array_handle>())).ndims as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_handle),
            "::",
            stringify!(ndims)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_array_handle>())).dims as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_handle),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_array_handle>())).dim0 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_handle),
            "::",
            stringify!(dim0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_array_handle>())).element_type as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_handle),
            "::",
            stringify!(element_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_array_handle>())).elements as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_handle),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<scm_t_array_handle>())).writable_elements as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_array_handle),
            "::",
            stringify!(writable_elements)
        )
    );
}
extern "C" {
    pub fn scm_array_get_handle(array: SCM, h: *mut scm_t_array_handle);
}
extern "C" {
    pub fn scm_array_handle_pos(h: *mut scm_t_array_handle, indices: SCM) -> ssize_t;
}
extern "C" {
    pub fn scm_array_handle_pos_1(h: *mut scm_t_array_handle, idx0: ssize_t) -> ssize_t;
}
extern "C" {
    pub fn scm_array_handle_pos_2(
        h: *mut scm_t_array_handle,
        idx0: ssize_t,
        idx1: ssize_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn scm_array_handle_element_type(h: *mut scm_t_array_handle) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_release(h: *mut scm_t_array_handle);
}
extern "C" {
    pub fn scm_array_handle_elements(h: *mut scm_t_array_handle) -> *const SCM;
}
extern "C" {
    pub fn scm_array_handle_writable_elements(h: *mut scm_t_array_handle) -> *mut SCM;
}
extern "C" {
    pub fn scm_init_array_handle();
}
extern "C" {
    pub fn scm_ra_matchp(ra0: SCM, ras: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_ramapc(
        cproc: *mut ::std::os::raw::c_void,
        data: SCM,
        ra0: SCM,
        lra: SCM,
        what: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_array_fill_x(ra: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_copy_x(src: SCM, dst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_map_x(ra0: SCM, proc_: SCM, lra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_for_each(proc_: SCM, ra0: SCM, lra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_index_map_x(ra: SCM, proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_equal_p(ra0: SCM, ra1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_array_map();
}
extern "C" {
    pub fn scm_array_fill_int(ra: SCM, fill: SCM, ignore: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_ra_eqp(ra0: SCM, ras: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_ra_lessp(ra0: SCM, ras: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_ra_leqp(ra0: SCM, ras: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_ra_grp(ra0: SCM, ras: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_ra_greqp(ra0: SCM, ras: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_ra_sum(ra0: SCM, ras: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_ra_difference(ra0: SCM, ras: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_ra_product(ra0: SCM, ras: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_ra_divide(ra0: SCM, ras: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_array_identity(src: SCM, dst: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Arrays"]
    pub fn scm_make_array(fill: SCM, bounds: SCM) -> SCM;
}
extern "C" {
    pub fn scm_from_contiguous_array(bounds: SCM, elts: *const SCM, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_make_typed_array(type_: SCM, fill: SCM, bounds: SCM) -> SCM;
}
extern "C" {
    pub fn scm_from_contiguous_typed_array(
        type_: SCM,
        bounds: SCM,
        bytes: *const ::std::os::raw::c_void,
        byte_len: size_t,
    ) -> SCM;
}
extern "C" {
    pub fn scm_shared_array_root(ra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_shared_array_offset(ra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_shared_array_increments(ra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_shared_array(oldra: SCM, mapfunc: SCM, dims: SCM) -> SCM;
}
extern "C" {
    pub fn scm_transpose_array(ra: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_contents(ra: SCM, strict: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_array(ndim: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_typed_array(type_: SCM, ndim: SCM, lst: SCM) -> SCM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_i_t_array {
    pub v: SCM,
    pub base: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_scm_i_t_array() {
    assert_eq!(
        ::std::mem::size_of::<scm_i_t_array>(),
        16usize,
        concat!("Size of: ", stringify!(scm_i_t_array))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_i_t_array>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_i_t_array))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_t_array>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_t_array),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_t_array>())).base as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_t_array),
            "::",
            stringify!(base)
        )
    );
}
extern "C" {
    pub fn scm_i_make_array(ndim: ::std::os::raw::c_int) -> SCM;
}
extern "C" {
    pub fn scm_i_print_array(
        array: SCM,
        port: SCM,
        pstate: *mut scm_print_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_init_arrays();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union scm_t_debug_info {
    pub e: scm_t_debug_info__bindgen_ty_1,
    pub a: scm_t_debug_info__bindgen_ty_2,
    pub id: SCM,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_debug_info__bindgen_ty_1 {
    pub exp: SCM,
    pub env: SCM,
}
#[test]
fn bindgen_test_layout_scm_t_debug_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_debug_info__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(scm_t_debug_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_debug_info__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_debug_info__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<scm_t_debug_info__bindgen_ty_1>())).exp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_debug_info__bindgen_ty_1),
            "::",
            stringify!(exp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<scm_t_debug_info__bindgen_ty_1>())).env as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_debug_info__bindgen_ty_1),
            "::",
            stringify!(env)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_debug_info__bindgen_ty_2 {
    pub proc_: SCM,
    pub args: SCM,
}
#[test]
fn bindgen_test_layout_scm_t_debug_info__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_debug_info__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(scm_t_debug_info__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_debug_info__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_debug_info__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<scm_t_debug_info__bindgen_ty_2>())).proc_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_debug_info__bindgen_ty_2),
            "::",
            stringify!(proc_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<scm_t_debug_info__bindgen_ty_2>())).args as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_debug_info__bindgen_ty_2),
            "::",
            stringify!(args)
        )
    );
}
#[test]
fn bindgen_test_layout_scm_t_debug_info() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_debug_info>(),
        16usize,
        concat!("Size of: ", stringify!(scm_t_debug_info))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_debug_info>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_debug_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_debug_info>())).e as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_debug_info),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_debug_info>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_debug_info),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_debug_info>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_debug_info),
            "::",
            stringify!(id)
        )
    );
}
extern "C" {
    pub fn scm_local_eval(exp: SCM, env: SCM) -> SCM;
}
extern "C" {
    pub fn scm_reverse_lookup(env: SCM, data: SCM) -> SCM;
}
extern "C" {
    pub fn scm_procedure_source(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_procedure_name(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_debug_options(setting: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_debug();
}
pub type scm_t_catch_body =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> SCM>;
pub type scm_t_catch_handler = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, tag: SCM, throw_args: SCM) -> SCM,
>;
extern "C" {
    pub fn scm_c_catch(
        tag: SCM,
        body: scm_t_catch_body,
        body_data: *mut ::std::os::raw::c_void,
        handler: scm_t_catch_handler,
        handler_data: *mut ::std::os::raw::c_void,
        pre_unwind_handler: scm_t_catch_handler,
        pre_unwind_handler_data: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_c_with_throw_handler(
        tag: SCM,
        body: scm_t_catch_body,
        body_data: *mut ::std::os::raw::c_void,
        handler: scm_t_catch_handler,
        handler_data: *mut ::std::os::raw::c_void,
        lazy_catch_p: ::std::os::raw::c_int,
    ) -> SCM;
}
extern "C" {
    pub fn scm_internal_catch(
        tag: SCM,
        body: scm_t_catch_body,
        body_data: *mut ::std::os::raw::c_void,
        handler: scm_t_catch_handler,
        handler_data: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_body_thunk_data {
    pub tag: SCM,
    pub body_proc: SCM,
}
#[test]
fn bindgen_test_layout_scm_body_thunk_data() {
    assert_eq!(
        ::std::mem::size_of::<scm_body_thunk_data>(),
        16usize,
        concat!("Size of: ", stringify!(scm_body_thunk_data))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_body_thunk_data>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_body_thunk_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_body_thunk_data>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_body_thunk_data),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_body_thunk_data>())).body_proc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_body_thunk_data),
            "::",
            stringify!(body_proc)
        )
    );
}
extern "C" {
    pub fn scm_body_thunk(arg1: *mut ::std::os::raw::c_void) -> SCM;
}
extern "C" {
    pub fn scm_handle_by_proc(arg1: *mut ::std::os::raw::c_void, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_handle_by_proc_catching_all(
        arg1: *mut ::std::os::raw::c_void,
        arg2: SCM,
        arg3: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_handle_by_message(arg1: *mut ::std::os::raw::c_void, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_handle_by_message_noexit(
        arg1: *mut ::std::os::raw::c_void,
        arg2: SCM,
        arg3: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_handle_by_throw(arg1: *mut ::std::os::raw::c_void, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_exit_status(args: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_catch_with_pre_unwind_handler(
        tag: SCM,
        thunk: SCM,
        handler: SCM,
        lazy_handler: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_catch(tag: SCM, thunk: SCM, handler: SCM) -> SCM;
}
extern "C" {
    pub fn scm_with_throw_handler(tag: SCM, thunk: SCM, handler: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ithrow(key: SCM, args: SCM, no_return: ::std::os::raw::c_int) -> SCM;
}
extern "C" {
    pub fn scm_throw(key: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_throw();
}
extern "C" {
    pub fn scm_internal_cwdr(
        body: scm_t_catch_body,
        body_data: *mut ::std::os::raw::c_void,
        handler: scm_t_catch_handler,
        handler_data: *mut ::std::os::raw::c_void,
        stack_start: *mut SCM_STACKITEM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_call_with_dynamic_root(thunk: SCM, handler: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynamic_root() -> SCM;
}
extern "C" {
    pub fn scm_apply_with_dynamic_root(proc_: SCM, a1: SCM, args: SCM, handler: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_root();
}
extern "C" {
    pub fn scm_procedure_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_thunk_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_procedure_documentation(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_procedure_with_setter_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_procedure_with_setter(procedure: SCM, setter: SCM) -> SCM;
}
extern "C" {
    pub fn scm_procedure(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setter(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_procs();
}
extern "C" {
    pub static mut scm_sym_documentation: SCM;
}
extern "C" {
    pub fn scm_std_select(
        fds: ::std::os::raw::c_int,
        rfds: *mut fd_set,
        wfds: *mut fd_set,
        efds: *mut fd_set,
        timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
pub type scm_t_guard =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn scm_dynamic_wind(thunk1: SCM, thunk2: SCM, thunk3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dowinds(to: SCM, delta: ::std::os::raw::c_long);
}
extern "C" {
    pub fn scm_i_dowinds(
        to: SCM,
        delta: ::std::os::raw::c_long,
        turn_func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn scm_init_dynwind();
}
extern "C" {
    pub fn scm_swap_bindings(vars: SCM, vals: SCM);
}
pub const scm_t_dynwind_flags_SCM_F_DYNWIND_REWINDABLE: scm_t_dynwind_flags = 1;
pub type scm_t_dynwind_flags = ::std::os::raw::c_uint;
pub const scm_t_wind_flags_SCM_F_WIND_EXPLICITLY: scm_t_wind_flags = 1;
pub type scm_t_wind_flags = ::std::os::raw::c_uint;
extern "C" {
    pub fn scm_dynwind_begin(arg1: scm_t_dynwind_flags);
}
extern "C" {
    pub fn scm_dynwind_end();
}
extern "C" {
    pub fn scm_dynwind_unwind_handler(
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        data: *mut ::std::os::raw::c_void,
        arg1: scm_t_wind_flags,
    );
}
extern "C" {
    pub fn scm_dynwind_rewind_handler(
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        data: *mut ::std::os::raw::c_void,
        arg1: scm_t_wind_flags,
    );
}
extern "C" {
    pub fn scm_dynwind_unwind_handler_with_scm(
        func: ::std::option::Option<unsafe extern "C" fn(arg1: SCM)>,
        data: SCM,
        arg1: scm_t_wind_flags,
    );
}
extern "C" {
    pub fn scm_dynwind_rewind_handler_with_scm(
        func: ::std::option::Option<unsafe extern "C" fn(arg1: SCM)>,
        data: SCM,
        arg1: scm_t_wind_flags,
    );
}
extern "C" {
    pub fn scm_dynwind_free(mem: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_contregs {
    pub jmpbuf: jmp_buf,
    pub dynenv: SCM,
    pub num_stack_items: size_t,
    pub root: SCM,
    pub vm: SCM,
    pub vm_cont: SCM,
    pub offset: scm_t_ptrdiff,
    pub stack: [SCM_STACKITEM; 1usize],
}
#[test]
fn bindgen_test_layout_scm_t_contregs() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_contregs>(),
        256usize,
        concat!("Size of: ", stringify!(scm_t_contregs))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_contregs>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_contregs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_contregs>())).jmpbuf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_contregs),
            "::",
            stringify!(jmpbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_contregs>())).dynenv as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_contregs),
            "::",
            stringify!(dynenv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_contregs>())).num_stack_items as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_contregs),
            "::",
            stringify!(num_stack_items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_contregs>())).root as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_contregs),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_contregs>())).vm as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_contregs),
            "::",
            stringify!(vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_contregs>())).vm_cont as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_contregs),
            "::",
            stringify!(vm_cont)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_contregs>())).offset as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_contregs),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_contregs>())).stack as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_contregs),
            "::",
            stringify!(stack)
        )
    );
}
extern "C" {
    pub fn scm_i_make_continuation(first: *mut ::std::os::raw::c_int, vm: SCM, vm_cont: SCM)
        -> SCM;
}
extern "C" {
    pub fn scm_i_check_continuation(cont: SCM);
}
extern "C" {
    pub fn scm_i_reinstate_continuation(cont: SCM);
}
extern "C" {
    pub fn scm_i_call_with_current_continuation(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_continuation_to_frame(cont: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_contregs_vm(contregs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_contregs_vm_cont(contregs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_with_continuation_barrier(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg1: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_with_continuation_barrier(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_with_continuation_barrier(
        body: scm_t_catch_body,
        body_data: *mut ::std::os::raw::c_void,
        handler: scm_t_catch_handler,
        handler_data: *mut ::std::os::raw::c_void,
        pre_unwind_handler: scm_t_catch_handler,
        pre_unwind_handler_data: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_init_continuations();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: size_t, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: size_t) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub const PTHREAD_CREATE_JOINABLE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CREATE_DETACHED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: ::std::os::raw::c_uint = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: ::std::os::raw::c_uint = 3;
pub const PTHREAD_MUTEX_NORMAL: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: ::std::os::raw::c_uint = 2;
pub const PTHREAD_MUTEX_DEFAULT: ::std::os::raw::c_uint = 0;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_STALLED_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_ROBUST: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_PRIO_INHERIT: ::std::os::raw::c_uint = 1;
pub const PTHREAD_PRIO_PROTECT: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: ::std::os::raw::c_uint = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: ::std::os::raw::c_uint = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: ::std::os::raw::c_uint = 0;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_EXPLICIT_SCHED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: ::std::os::raw::c_uint = 0;
pub const PTHREAD_SCOPE_PROCESS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_PROCESS_SHARED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CANCEL_DISABLE: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___cancel_jmp_buf_tag() {
    assert_eq!(
        ::std::mem::size_of::<__cancel_jmp_buf_tag>(),
        72usize,
        concat!("Size of: ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__cancel_jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__cancel_jmp_buf_tag>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__cancel_jmp_buf_tag>())).__mask_was_saved as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type GC_PTR = *mut ::std::os::raw::c_void;
pub type GC_word = ::std::os::raw::c_ulong;
pub type GC_signed_word = ::std::os::raw::c_long;
extern "C" {
    pub fn GC_get_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut GC_gc_no: GC_word;
}
extern "C" {
    pub fn GC_get_gc_no() -> GC_word;
}
extern "C" {
    pub static mut GC_parallel: ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_get_parallel() -> ::std::os::raw::c_int;
}
pub type GC_oom_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: size_t) -> *mut ::std::os::raw::c_void>;
extern "C" {
    pub static mut GC_oom_fn: GC_oom_func;
}
extern "C" {
    pub fn GC_set_oom_fn(arg1: GC_oom_func);
}
extern "C" {
    pub fn GC_get_oom_fn() -> GC_oom_func;
}
pub type GC_on_heap_resize_proc = ::std::option::Option<unsafe extern "C" fn(arg1: GC_word)>;
extern "C" {
    pub static mut GC_on_heap_resize: GC_on_heap_resize_proc;
}
extern "C" {
    pub fn GC_set_on_heap_resize(arg1: GC_on_heap_resize_proc);
}
extern "C" {
    pub fn GC_get_on_heap_resize() -> GC_on_heap_resize_proc;
}
pub const GC_EventType_GC_EVENT_START: GC_EventType = 0;
pub const GC_EventType_GC_EVENT_MARK_START: GC_EventType = 1;
pub const GC_EventType_GC_EVENT_MARK_END: GC_EventType = 2;
pub const GC_EventType_GC_EVENT_RECLAIM_START: GC_EventType = 3;
pub const GC_EventType_GC_EVENT_RECLAIM_END: GC_EventType = 4;
pub const GC_EventType_GC_EVENT_END: GC_EventType = 5;
pub const GC_EventType_GC_EVENT_PRE_STOP_WORLD: GC_EventType = 6;
pub const GC_EventType_GC_EVENT_POST_STOP_WORLD: GC_EventType = 7;
pub const GC_EventType_GC_EVENT_PRE_START_WORLD: GC_EventType = 8;
pub const GC_EventType_GC_EVENT_POST_START_WORLD: GC_EventType = 9;
pub const GC_EventType_GC_EVENT_THREAD_SUSPENDED: GC_EventType = 10;
pub const GC_EventType_GC_EVENT_THREAD_UNSUSPENDED: GC_EventType = 11;
pub type GC_EventType = ::std::os::raw::c_uint;
pub type GC_on_collection_event_proc =
    ::std::option::Option<unsafe extern "C" fn(arg1: GC_EventType)>;
extern "C" {
    pub fn GC_set_on_collection_event(arg1: GC_on_collection_event_proc);
}
extern "C" {
    pub fn GC_get_on_collection_event() -> GC_on_collection_event_proc;
}
pub type GC_on_thread_event_proc = ::std::option::Option<
    unsafe extern "C" fn(arg1: GC_EventType, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn GC_set_on_thread_event(arg1: GC_on_thread_event_proc);
}
extern "C" {
    pub fn GC_get_on_thread_event() -> GC_on_thread_event_proc;
}
extern "C" {
    pub static mut GC_find_leak: ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_set_find_leak(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GC_get_find_leak() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut GC_all_interior_pointers: ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_set_all_interior_pointers(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GC_get_all_interior_pointers() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut GC_finalize_on_demand: ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_set_finalize_on_demand(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GC_get_finalize_on_demand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut GC_java_finalization: ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_set_java_finalization(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GC_get_java_finalization() -> ::std::os::raw::c_int;
}
pub type GC_finalizer_notifier_proc = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut GC_finalizer_notifier: GC_finalizer_notifier_proc;
}
extern "C" {
    pub fn GC_set_finalizer_notifier(arg1: GC_finalizer_notifier_proc);
}
extern "C" {
    pub fn GC_get_finalizer_notifier() -> GC_finalizer_notifier_proc;
}
extern "C" {
    pub static mut GC_dont_gc: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut GC_dont_expand: ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_set_dont_expand(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GC_get_dont_expand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut GC_use_entire_heap: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut GC_full_freq: ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_set_full_freq(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GC_get_full_freq() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut GC_non_gc_bytes: GC_word;
}
extern "C" {
    pub fn GC_set_non_gc_bytes(arg1: GC_word);
}
extern "C" {
    pub fn GC_get_non_gc_bytes() -> GC_word;
}
extern "C" {
    pub static mut GC_no_dls: ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_set_no_dls(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GC_get_no_dls() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut GC_free_space_divisor: GC_word;
}
extern "C" {
    pub fn GC_set_free_space_divisor(arg1: GC_word);
}
extern "C" {
    pub fn GC_get_free_space_divisor() -> GC_word;
}
extern "C" {
    pub static mut GC_max_retries: GC_word;
}
extern "C" {
    pub fn GC_set_max_retries(arg1: GC_word);
}
extern "C" {
    pub fn GC_get_max_retries() -> GC_word;
}
extern "C" {
    pub static mut GC_stackbottom: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut GC_dont_precollect: ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_set_dont_precollect(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GC_get_dont_precollect() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut GC_time_limit: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn GC_set_time_limit(arg1: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn GC_get_time_limit() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn GC_start_performance_measurement();
}
extern "C" {
    pub fn GC_get_full_gc_total_time() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn GC_set_pages_executable(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GC_get_pages_executable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_set_min_bytes_allocd(arg1: size_t);
}
extern "C" {
    pub fn GC_get_min_bytes_allocd() -> size_t;
}
extern "C" {
    pub fn GC_set_rate(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GC_get_rate() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_set_max_prior_attempts(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GC_get_max_prior_attempts() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_set_handle_fork(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GC_atfork_prepare();
}
extern "C" {
    pub fn GC_atfork_parent();
}
extern "C" {
    pub fn GC_atfork_child();
}
extern "C" {
    pub fn GC_init();
}
extern "C" {
    pub fn GC_is_init_called() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_deinit();
}
extern "C" {
    pub fn GC_malloc(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_malloc_atomic(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_strdup(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn GC_strndup(
        arg1: *const ::std::os::raw::c_char,
        arg2: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn GC_malloc_uncollectable(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_malloc_stubborn(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_memalign(arg1: size_t, arg2: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_posix_memalign(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn GC_change_stubborn(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn GC_end_stubborn_change(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn GC_base(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_is_heap_ptr(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_size(arg1: *const ::std::os::raw::c_void) -> size_t;
}
extern "C" {
    pub fn GC_realloc(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_expand_hp(arg1: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_set_max_heap_size(arg1: GC_word);
}
extern "C" {
    pub fn GC_exclude_static_roots(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn GC_clear_roots();
}
extern "C" {
    pub fn GC_add_roots(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn GC_remove_roots(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn GC_register_displacement(arg1: size_t);
}
extern "C" {
    pub fn GC_debug_register_displacement(arg1: size_t);
}
extern "C" {
    pub fn GC_gcollect();
}
extern "C" {
    pub fn GC_gcollect_and_unmap();
}
pub type GC_stop_func = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn GC_try_to_collect(arg1: GC_stop_func) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_set_stop_func(arg1: GC_stop_func);
}
extern "C" {
    pub fn GC_get_stop_func() -> GC_stop_func;
}
extern "C" {
    pub fn GC_get_heap_size() -> size_t;
}
extern "C" {
    pub fn GC_get_free_bytes() -> size_t;
}
extern "C" {
    pub fn GC_get_unmapped_bytes() -> size_t;
}
extern "C" {
    pub fn GC_get_bytes_since_gc() -> size_t;
}
extern "C" {
    pub fn GC_get_expl_freed_bytes_since_gc() -> size_t;
}
extern "C" {
    pub fn GC_get_total_bytes() -> size_t;
}
extern "C" {
    pub fn GC_get_heap_usage_safe(
        arg1: *mut GC_word,
        arg2: *mut GC_word,
        arg3: *mut GC_word,
        arg4: *mut GC_word,
        arg5: *mut GC_word,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GC_prof_stats_s {
    pub heapsize_full: GC_word,
    pub free_bytes_full: GC_word,
    pub unmapped_bytes: GC_word,
    pub bytes_allocd_since_gc: GC_word,
    pub allocd_bytes_before_gc: GC_word,
    pub non_gc_bytes: GC_word,
    pub gc_no: GC_word,
    pub markers_m1: GC_word,
    pub bytes_reclaimed_since_gc: GC_word,
    pub reclaimed_bytes_before_gc: GC_word,
    pub expl_freed_bytes_since_gc: GC_word,
}
#[test]
fn bindgen_test_layout_GC_prof_stats_s() {
    assert_eq!(
        ::std::mem::size_of::<GC_prof_stats_s>(),
        88usize,
        concat!("Size of: ", stringify!(GC_prof_stats_s))
    );
    assert_eq!(
        ::std::mem::align_of::<GC_prof_stats_s>(),
        8usize,
        concat!("Alignment of ", stringify!(GC_prof_stats_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GC_prof_stats_s>())).heapsize_full as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GC_prof_stats_s),
            "::",
            stringify!(heapsize_full)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GC_prof_stats_s>())).free_bytes_full as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GC_prof_stats_s),
            "::",
            stringify!(free_bytes_full)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GC_prof_stats_s>())).unmapped_bytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GC_prof_stats_s),
            "::",
            stringify!(unmapped_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GC_prof_stats_s>())).bytes_allocd_since_gc as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GC_prof_stats_s),
            "::",
            stringify!(bytes_allocd_since_gc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GC_prof_stats_s>())).allocd_bytes_before_gc as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GC_prof_stats_s),
            "::",
            stringify!(allocd_bytes_before_gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GC_prof_stats_s>())).non_gc_bytes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GC_prof_stats_s),
            "::",
            stringify!(non_gc_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GC_prof_stats_s>())).gc_no as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GC_prof_stats_s),
            "::",
            stringify!(gc_no)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GC_prof_stats_s>())).markers_m1 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GC_prof_stats_s),
            "::",
            stringify!(markers_m1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GC_prof_stats_s>())).bytes_reclaimed_since_gc as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GC_prof_stats_s),
            "::",
            stringify!(bytes_reclaimed_since_gc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GC_prof_stats_s>())).reclaimed_bytes_before_gc as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(GC_prof_stats_s),
            "::",
            stringify!(reclaimed_bytes_before_gc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GC_prof_stats_s>())).expl_freed_bytes_since_gc as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(GC_prof_stats_s),
            "::",
            stringify!(expl_freed_bytes_since_gc)
        )
    );
}
extern "C" {
    pub fn GC_get_prof_stats(arg1: *mut GC_prof_stats_s, arg2: size_t) -> size_t;
}
extern "C" {
    pub fn GC_get_prof_stats_unsafe(arg1: *mut GC_prof_stats_s, arg2: size_t) -> size_t;
}
extern "C" {
    pub fn GC_get_size_map_at(i: ::std::os::raw::c_int) -> size_t;
}
extern "C" {
    pub fn GC_get_memory_use() -> size_t;
}
extern "C" {
    pub fn GC_disable();
}
extern "C" {
    pub fn GC_is_disabled() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_enable();
}
extern "C" {
    pub fn GC_set_manual_vdb_allowed(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GC_get_manual_vdb_allowed() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_enable_incremental();
}
extern "C" {
    pub fn GC_is_incremental_mode() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_incremental_protection_needs() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_collect_a_little() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_malloc_ignore_off_page(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_malloc_atomic_ignore_off_page(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_malloc_atomic_uncollectable(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_debug_malloc_atomic_uncollectable(
        arg1: size_t,
        s: *const ::std::os::raw::c_char,
        i: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_debug_malloc(
        arg1: size_t,
        s: *const ::std::os::raw::c_char,
        i: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_debug_malloc_atomic(
        arg1: size_t,
        s: *const ::std::os::raw::c_char,
        i: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_debug_strdup(
        arg1: *const ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
        i: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn GC_debug_strndup(
        arg1: *const ::std::os::raw::c_char,
        arg2: size_t,
        s: *const ::std::os::raw::c_char,
        i: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn GC_debug_malloc_uncollectable(
        arg1: size_t,
        s: *const ::std::os::raw::c_char,
        i: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_debug_malloc_stubborn(
        arg1: size_t,
        s: *const ::std::os::raw::c_char,
        i: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_debug_malloc_ignore_off_page(
        arg1: size_t,
        s: *const ::std::os::raw::c_char,
        i: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_debug_malloc_atomic_ignore_off_page(
        arg1: size_t,
        s: *const ::std::os::raw::c_char,
        i: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_debug_free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn GC_debug_realloc(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        s: *const ::std::os::raw::c_char,
        i: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_debug_change_stubborn(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn GC_debug_end_stubborn_change(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn GC_debug_malloc_replacement(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_debug_realloc_replacement(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
pub type GC_finalization_proc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn GC_register_finalizer(
        arg1: *mut ::std::os::raw::c_void,
        arg2: GC_finalization_proc,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut GC_finalization_proc,
        arg5: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn GC_debug_register_finalizer(
        arg1: *mut ::std::os::raw::c_void,
        arg2: GC_finalization_proc,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut GC_finalization_proc,
        arg5: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn GC_register_finalizer_ignore_self(
        arg1: *mut ::std::os::raw::c_void,
        arg2: GC_finalization_proc,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut GC_finalization_proc,
        arg5: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn GC_debug_register_finalizer_ignore_self(
        arg1: *mut ::std::os::raw::c_void,
        arg2: GC_finalization_proc,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut GC_finalization_proc,
        arg5: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn GC_register_finalizer_no_order(
        arg1: *mut ::std::os::raw::c_void,
        arg2: GC_finalization_proc,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut GC_finalization_proc,
        arg5: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn GC_debug_register_finalizer_no_order(
        arg1: *mut ::std::os::raw::c_void,
        arg2: GC_finalization_proc,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut GC_finalization_proc,
        arg5: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn GC_register_finalizer_unreachable(
        arg1: *mut ::std::os::raw::c_void,
        arg2: GC_finalization_proc,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut GC_finalization_proc,
        arg5: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn GC_debug_register_finalizer_unreachable(
        arg1: *mut ::std::os::raw::c_void,
        arg2: GC_finalization_proc,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut GC_finalization_proc,
        arg5: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn GC_register_disappearing_link(
        arg1: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_general_register_disappearing_link(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_move_disappearing_link(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_unregister_disappearing_link(
        arg1: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_register_long_link(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_move_long_link(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_unregister_long_link(arg1: *mut *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
pub const GC_ToggleRefStatus_GC_TOGGLE_REF_DROP: GC_ToggleRefStatus = 0;
pub const GC_ToggleRefStatus_GC_TOGGLE_REF_STRONG: GC_ToggleRefStatus = 1;
pub const GC_ToggleRefStatus_GC_TOGGLE_REF_WEAK: GC_ToggleRefStatus = 2;
pub type GC_ToggleRefStatus = ::std::os::raw::c_uint;
pub type GC_toggleref_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> GC_ToggleRefStatus,
>;
extern "C" {
    pub fn GC_set_toggleref_func(arg1: GC_toggleref_func);
}
extern "C" {
    pub fn GC_get_toggleref_func() -> GC_toggleref_func;
}
extern "C" {
    pub fn GC_toggleref_add(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type GC_await_finalize_proc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn GC_set_await_finalize_proc(arg1: GC_await_finalize_proc);
}
extern "C" {
    pub fn GC_get_await_finalize_proc() -> GC_await_finalize_proc;
}
extern "C" {
    pub fn GC_should_invoke_finalizers() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_invoke_finalizers() -> ::std::os::raw::c_int;
}
pub type GC_warn_proc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char, arg2: GC_word)>;
extern "C" {
    pub fn GC_set_warn_proc(arg1: GC_warn_proc);
}
extern "C" {
    pub fn GC_get_warn_proc() -> GC_warn_proc;
}
extern "C" {
    pub fn GC_ignore_warn_proc(arg1: *mut ::std::os::raw::c_char, arg2: GC_word);
}
extern "C" {
    pub fn GC_set_log_fd(arg1: ::std::os::raw::c_int);
}
pub type GC_abort_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn GC_set_abort_func(arg1: GC_abort_func);
}
extern "C" {
    pub fn GC_get_abort_func() -> GC_abort_func;
}
extern "C" {
    pub fn GC_abort_on_oom();
}
pub type GC_hidden_pointer = GC_word;
pub type GC_fn_type = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn GC_call_with_alloc_lock(
        arg1: GC_fn_type,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GC_stack_base {
    pub mem_base: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_GC_stack_base() {
    assert_eq!(
        ::std::mem::size_of::<GC_stack_base>(),
        8usize,
        concat!("Size of: ", stringify!(GC_stack_base))
    );
    assert_eq!(
        ::std::mem::align_of::<GC_stack_base>(),
        8usize,
        concat!("Alignment of ", stringify!(GC_stack_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GC_stack_base>())).mem_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GC_stack_base),
            "::",
            stringify!(mem_base)
        )
    );
}
pub type GC_stack_base_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GC_stack_base,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn GC_call_with_stack_base(
        arg1: GC_stack_base_func,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_set_suspend_signal(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GC_set_thr_restart_signal(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GC_get_suspend_signal() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_get_thr_restart_signal() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_start_mark_threads();
}
extern "C" {
    pub fn GC_allow_register_threads();
}
extern "C" {
    pub fn GC_register_my_thread(arg1: *const GC_stack_base) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_thread_is_registered() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_register_altstack(
        arg1: *mut ::std::os::raw::c_void,
        arg2: GC_word,
        arg3: *mut ::std::os::raw::c_void,
        arg4: GC_word,
    );
}
extern "C" {
    pub fn GC_unregister_my_thread() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_stop_world_external();
}
extern "C" {
    pub fn GC_start_world_external();
}
extern "C" {
    pub fn GC_do_blocking(
        arg1: GC_fn_type,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_call_with_gc_active(
        arg1: GC_fn_type,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_get_stack_base(arg1: *mut GC_stack_base) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_same_obj(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_pre_incr(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: isize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_post_incr(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: isize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_is_visible(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_is_valid_displacement(
        arg1: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_dump();
}
extern "C" {
    pub fn GC_dump_named(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn GC_dump_regions();
}
extern "C" {
    pub fn GC_dump_finalization();
}
extern "C" {
    pub fn GC_ptr_store_and_dirty(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn GC_debug_ptr_store_and_dirty(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub static mut GC_same_obj_print_proc: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void),
    >;
}
extern "C" {
    pub static mut GC_is_valid_displacement_print_proc:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
}
extern "C" {
    pub static mut GC_is_visible_print_proc:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
}
extern "C" {
    pub fn dlopen(
        __file: *const ::std::os::raw::c_char,
        __mode: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dlclose(__handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dlsym(
        __handle: *mut ::std::os::raw::c_void,
        __name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dlerror() -> *mut ::std::os::raw::c_char;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub __pad0: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_1>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_1>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_tid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_overrun as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_sigval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_sigval)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_sigval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_sigval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_status as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_utime as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_utime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_stime as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_stime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
            >()))
            ._lower as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
            >()))
            ._upper as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))
                ._addr_bnd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))._pkey
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_pkey)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr_lsb
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr_lsb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>()))._bounds as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_bounds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_6>())).si_band as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_6>())).si_fd as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._call_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._syscall as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._arch as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._kill as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigchld as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigfault as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigpoll as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigsys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigsys)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).__pad0 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>()))._sifields as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(_sifields)
        )
    );
}
pub const SI_ASYNCNL: ::std::os::raw::c_int = -60;
pub const SI_DETHREAD: ::std::os::raw::c_int = -7;
pub const SI_TKILL: ::std::os::raw::c_int = -6;
pub const SI_SIGIO: ::std::os::raw::c_int = -5;
pub const SI_ASYNCIO: ::std::os::raw::c_int = -4;
pub const SI_MESGQ: ::std::os::raw::c_int = -3;
pub const SI_TIMER: ::std::os::raw::c_int = -2;
pub const SI_QUEUE: ::std::os::raw::c_int = -1;
pub const SI_USER: ::std::os::raw::c_int = 0;
pub const SI_KERNEL: ::std::os::raw::c_int = 128;
pub type _bindgen_ty_12 = ::std::os::raw::c_int;
pub const ILL_ILLOPC: ::std::os::raw::c_uint = 1;
pub const ILL_ILLOPN: ::std::os::raw::c_uint = 2;
pub const ILL_ILLADR: ::std::os::raw::c_uint = 3;
pub const ILL_ILLTRP: ::std::os::raw::c_uint = 4;
pub const ILL_PRVOPC: ::std::os::raw::c_uint = 5;
pub const ILL_PRVREG: ::std::os::raw::c_uint = 6;
pub const ILL_COPROC: ::std::os::raw::c_uint = 7;
pub const ILL_BADSTK: ::std::os::raw::c_uint = 8;
pub const ILL_BADIADDR: ::std::os::raw::c_uint = 9;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const FPE_INTDIV: ::std::os::raw::c_uint = 1;
pub const FPE_INTOVF: ::std::os::raw::c_uint = 2;
pub const FPE_FLTDIV: ::std::os::raw::c_uint = 3;
pub const FPE_FLTOVF: ::std::os::raw::c_uint = 4;
pub const FPE_FLTUND: ::std::os::raw::c_uint = 5;
pub const FPE_FLTRES: ::std::os::raw::c_uint = 6;
pub const FPE_FLTINV: ::std::os::raw::c_uint = 7;
pub const FPE_FLTSUB: ::std::os::raw::c_uint = 8;
pub const FPE_FLTUNK: ::std::os::raw::c_uint = 14;
pub const FPE_CONDTRAP: ::std::os::raw::c_uint = 15;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const SEGV_MAPERR: ::std::os::raw::c_uint = 1;
pub const SEGV_ACCERR: ::std::os::raw::c_uint = 2;
pub const SEGV_BNDERR: ::std::os::raw::c_uint = 3;
pub const SEGV_PKUERR: ::std::os::raw::c_uint = 4;
pub const SEGV_ACCADI: ::std::os::raw::c_uint = 5;
pub const SEGV_ADIDERR: ::std::os::raw::c_uint = 6;
pub const SEGV_ADIPERR: ::std::os::raw::c_uint = 7;
pub const SEGV_MTEAERR: ::std::os::raw::c_uint = 8;
pub const SEGV_MTESERR: ::std::os::raw::c_uint = 9;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const BUS_ADRALN: ::std::os::raw::c_uint = 1;
pub const BUS_ADRERR: ::std::os::raw::c_uint = 2;
pub const BUS_OBJERR: ::std::os::raw::c_uint = 3;
pub const BUS_MCEERR_AR: ::std::os::raw::c_uint = 4;
pub const BUS_MCEERR_AO: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const CLD_EXITED: ::std::os::raw::c_uint = 1;
pub const CLD_KILLED: ::std::os::raw::c_uint = 2;
pub const CLD_DUMPED: ::std::os::raw::c_uint = 3;
pub const CLD_TRAPPED: ::std::os::raw::c_uint = 4;
pub const CLD_STOPPED: ::std::os::raw::c_uint = 5;
pub const CLD_CONTINUED: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const POLL_IN: ::std::os::raw::c_uint = 1;
pub const POLL_OUT: ::std::os::raw::c_uint = 2;
pub const POLL_MSG: ::std::os::raw::c_uint = 3;
pub const POLL_ERR: ::std::os::raw::c_uint = 4;
pub const POLL_PRI: ::std::os::raw::c_uint = 5;
pub const POLL_HUP: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
pub type sigval_t = __sigval_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._function as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._attribute as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._sigev_thread as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>()))._sigev_un as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: ::std::os::raw::c_uint = 0;
pub const SIGEV_NONE: ::std::os::raw::c_uint = 1;
pub const SIGEV_THREAD: ::std::os::raw::c_uint = 2;
pub const SIGEV_THREAD_ID: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
        -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(
        __set: *const sigset_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_handler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_sigaction as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        152usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_restorer as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
extern "C" {
    pub fn sigprocmask(
        __how: ::std::os::raw::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(
        __sig: ::std::os::raw::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        __set: *const sigset_t,
        __sig: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigqueue(
        __pid: __pid_t,
        __sig: ::std::os::raw::c_int,
        __val: sigval,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub __glibc_reserved1: [__uint32_t; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(
        ::std::mem::size_of::<_fpx_sw_bytes>(),
        48usize,
        concat!("Size of: ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpx_sw_bytes>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).magic1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(magic1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).extended_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(extended_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_bv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).__glibc_reserved1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpreg>(),
        10usize,
        concat!("Size of: ", stringify!(_fpreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(exponent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).__glibc_reserved1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(
        ::std::mem::size_of::<_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__fpstate() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).ftw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).mxcr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>()))._st as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>()))._xmm as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).__glibc_reserved1 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
}
#[test]
fn bindgen_test_layout_sigcontext__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigcontext__bindgen_ty_1>())).fpstate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigcontext__bindgen_ty_1>())).__fpstate_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(__fpstate_word)
        )
    );
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext>(),
        256usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r9 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r10 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r11 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r12 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r13 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r14 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r15 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rdi as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rsi as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rbp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rbx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rdx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rax as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rcx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rsp as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).eflags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(eflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).cs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).gs as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).fs as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__pad0 as *const _ as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).err as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).trapno as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).oldmask as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).cr2 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub __glibc_reserved1: [__uint64_t; 2usize],
    pub __glibc_reserved2: [__uint64_t; 5usize],
}
#[test]
fn bindgen_test_layout__xsave_hdr() {
    assert_eq!(
        ::std::mem::size_of::<_xsave_hdr>(),
        64usize,
        concat!("Size of: ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<_xsave_hdr>(),
        8usize,
        concat!("Alignment of ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).xstate_bv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).__glibc_reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).__glibc_reserved2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(__glibc_reserved2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(
        ::std::mem::size_of::<_ymmh_state>(),
        256usize,
        concat!("Size of: ", stringify!(_ymmh_state))
    );
    assert_eq!(
        ::std::mem::align_of::<_ymmh_state>(),
        4usize,
        concat!("Alignment of ", stringify!(_ymmh_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ymmh_state>())).ymmh_space as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ymmh_state),
            "::",
            stringify!(ymmh_space)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(
        ::std::mem::size_of::<_xstate>(),
        832usize,
        concat!("Size of: ", stringify!(_xstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_xstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_xstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).fpstate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).xstate_hdr as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(xstate_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).ymmh as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(ymmh)
        )
    );
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: size_t,
}
#[test]
fn bindgen_test_layout_stack_t() {
    assert_eq!(
        ::std::mem::size_of::<stack_t>(),
        24usize,
        concat!("Size of: ", stringify!(stack_t))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_t>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_t>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_t>())).ss_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_t>())).ss_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_size)
        )
    );
}
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__libc_fpxreg() {
    assert_eq!(
        ::std::mem::size_of::<_libc_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).__glibc_reserved1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__libc_xmmreg() {
    assert_eq!(
        ::std::mem::size_of::<_libc_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__libc_fpstate() {
    assert_eq!(
        ::std::mem::size_of::<_libc_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).ftw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).mxcr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>()))._st as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>()))._xmm as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).__glibc_reserved1 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    assert_eq!(
        ::std::mem::size_of::<mcontext_t>(),
        256usize,
        concat!("Size of: ", stringify!(mcontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mcontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mcontext_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).gregs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(gregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).fpregs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(fpregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).__reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(__reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
    pub __ssp: [::std::os::raw::c_ulonglong; 4usize],
}
#[test]
fn bindgen_test_layout_ucontext_t() {
    assert_eq!(
        ::std::mem::size_of::<ucontext_t>(),
        968usize,
        concat!("Size of: ", stringify!(ucontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucontext_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_link as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_stack as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_mcontext as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_mcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_sigmask as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).__fpregs_mem as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(__fpregs_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).__ssp as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(__ssp)
        )
    );
}
extern "C" {
    pub fn siginterrupt(
        __sig: ::std::os::raw::c_int,
        __interrupt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const SS_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SS_DISABLE: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
extern "C" {
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        __how: ::std::os::raw::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(
        __threadid: pthread_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_dlopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GC_pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_pthread_create(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_pthread_join(
        arg1: pthread_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_pthread_detach(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_pthread_cancel(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_pthread_exit(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn GC_malloc_many(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
pub type GC_has_static_roots_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn GC_register_has_static_roots_callback(arg1: GC_has_static_roots_func);
}
extern "C" {
    pub fn GC_set_force_unmap_on_gcollect(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GC_get_force_unmap_on_gcollect() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GC_win32_free_heap();
}
extern "C" {
    pub static mut scm_i_pthread_mutexattr_recursive: [pthread_mutexattr_t; 1usize];
}
extern "C" {
    pub static mut scm_tc16_thread: scm_t_bits;
}
extern "C" {
    pub static mut scm_tc16_mutex: scm_t_bits;
}
extern "C" {
    pub static mut scm_tc16_condvar: scm_t_bits;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct scm_i_thread {
    pub next_thread: *mut scm_i_thread,
    pub handle: SCM,
    pub pthread: pthread_t,
    pub cleanup_handler: SCM,
    pub join_queue: SCM,
    pub admin_mutex: pthread_mutex_t,
    pub mutexes: SCM,
    pub held_mutex: *mut pthread_mutex_t,
    pub result: SCM,
    pub canceled: ::std::os::raw::c_int,
    pub exited: ::std::os::raw::c_int,
    pub guile_mode: ::std::os::raw::c_int,
    pub sleep_object: SCM,
    pub sleep_mutex: *mut pthread_mutex_t,
    pub sleep_cond: pthread_cond_t,
    pub sleep_fd: ::std::os::raw::c_int,
    pub sleep_pipe: [::std::os::raw::c_int; 2usize],
    pub current_mark_stack_ptr: *mut ::std::os::raw::c_void,
    pub current_mark_stack_limit: *mut ::std::os::raw::c_void,
    pub dynamic_state: SCM,
    pub dynwinds: SCM,
    pub active_asyncs: SCM,
    pub block_asyncs: ::std::os::raw::c_uint,
    pub pending_asyncs: ::std::os::raw::c_uint,
    pub continuation_root: SCM,
    pub continuation_base: *mut SCM_STACKITEM,
    pub vm: SCM,
    pub base: *mut SCM_STACKITEM,
    pub regs: jmp_buf,
    pub critical_section_level: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_scm_i_thread() {
    assert_eq!(
        ::std::mem::size_of::<scm_i_thread>(),
        488usize,
        concat!("Size of: ", stringify!(scm_i_thread))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_i_thread>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_i_thread))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).next_thread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(next_thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).pthread as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(pthread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).cleanup_handler as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(cleanup_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).join_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(join_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).admin_mutex as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(admin_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).mutexes as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(mutexes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).held_mutex as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(held_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).result as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).canceled as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(canceled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).exited as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(exited)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).guile_mode as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(guile_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).sleep_object as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(sleep_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).sleep_mutex as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(sleep_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).sleep_cond as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(sleep_cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).sleep_fd as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(sleep_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).sleep_pipe as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(sleep_pipe)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<scm_i_thread>())).current_mark_stack_ptr as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(current_mark_stack_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<scm_i_thread>())).current_mark_stack_limit as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(current_mark_stack_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).dynamic_state as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(dynamic_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).dynwinds as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(dynwinds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).active_asyncs as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(active_asyncs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).block_asyncs as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(block_asyncs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).pending_asyncs as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(pending_asyncs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).continuation_root as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(continuation_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).continuation_base as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(continuation_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).vm as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).base as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_i_thread>())).regs as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<scm_i_thread>())).critical_section_level as *const _ as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_i_thread),
            "::",
            stringify!(critical_section_level)
        )
    );
}
extern "C" {
    pub fn scm_spawn_thread(
        body: scm_t_catch_body,
        body_data: *mut ::std::os::raw::c_void,
        handler: scm_t_catch_handler,
        handler_data: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_without_guile(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_with_guile(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_i_reset_fluid(arg1: size_t);
}
extern "C" {
    pub fn scm_threads_prehistory(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_init_threads();
}
extern "C" {
    pub fn scm_init_thread_procs();
}
extern "C" {
    pub fn scm_init_threads_default_dynamic_state();
}
extern "C" {
    pub fn scm_i_dynwind_pthread_mutex_lock_block_asyncs(mutex: *mut pthread_mutex_t);
}
extern "C" {
    pub fn scm_call_with_new_thread(thunk: SCM, handler: SCM) -> SCM;
}
extern "C" {
    pub fn scm_yield() -> SCM;
}
extern "C" {
    pub fn scm_cancel_thread(t: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_thread_cleanup_x(thread: SCM, proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_thread_cleanup(thread: SCM) -> SCM;
}
extern "C" {
    pub fn scm_join_thread(t: SCM) -> SCM;
}
extern "C" {
    pub fn scm_join_thread_timed(t: SCM, timeout: SCM, timeoutval: SCM) -> SCM;
}
extern "C" {
    pub fn scm_thread_p(t: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_mutex() -> SCM;
}
extern "C" {
    pub fn scm_make_recursive_mutex() -> SCM;
}
extern "C" {
    pub fn scm_make_mutex_with_flags(flags: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lock_mutex(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lock_mutex_timed(m: SCM, timeout: SCM, owner: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynwind_lock_mutex(mutex: SCM);
}
extern "C" {
    pub fn scm_try_mutex(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_unlock_mutex(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_unlock_mutex_timed(m: SCM, cond: SCM, timeout: SCM) -> SCM;
}
extern "C" {
    pub fn scm_mutex_p(o: SCM) -> SCM;
}
extern "C" {
    pub fn scm_mutex_locked_p(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_mutex_owner(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_mutex_level(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_condition_variable() -> SCM;
}
extern "C" {
    pub fn scm_wait_condition_variable(cond: SCM, mutex: SCM) -> SCM;
}
extern "C" {
    pub fn scm_timed_wait_condition_variable(cond: SCM, mutex: SCM, abstime: SCM) -> SCM;
}
extern "C" {
    pub fn scm_signal_condition_variable(cond: SCM) -> SCM;
}
extern "C" {
    pub fn scm_broadcast_condition_variable(cond: SCM) -> SCM;
}
extern "C" {
    pub fn scm_condition_variable_p(o: SCM) -> SCM;
}
extern "C" {
    pub fn scm_current_thread() -> SCM;
}
extern "C" {
    pub fn scm_all_threads() -> SCM;
}
extern "C" {
    pub fn scm_c_thread_exited_p(thread: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_thread_exited_p(thread: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynwind_critical_section(mutex: SCM);
}
extern "C" {
    pub static mut scm_i_misc_mutex: pthread_mutex_t;
}
extern "C" {
    pub fn scm_pthread_mutex_lock(mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_dynwind_pthread_mutex_lock(mutex: *mut pthread_mutex_t);
}
extern "C" {
    pub fn scm_pthread_cond_wait(
        cond: *mut pthread_cond_t,
        mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_pthread_cond_timedwait(
        cond: *mut pthread_cond_t,
        mutex: *mut pthread_mutex_t,
        abstime: *const scm_t_timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_std_sleep(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn scm_std_usleep(arg1: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_total_processor_count() -> SCM;
}
extern "C" {
    pub fn scm_current_processor_count() -> SCM;
}
extern "C" {
    pub fn scm_async_click();
}
extern "C" {
    pub fn scm_switch();
}
extern "C" {
    pub fn scm_async(thunk: SCM) -> SCM;
}
extern "C" {
    pub fn scm_async_mark(a: SCM) -> SCM;
}
extern "C" {
    pub fn scm_system_async_mark(a: SCM) -> SCM;
}
extern "C" {
    pub fn scm_system_async_mark_for_thread(a: SCM, thread: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_queue_async_cell(cell: SCM, arg1: *mut scm_i_thread);
}
extern "C" {
    pub fn scm_i_setup_sleep(
        arg1: *mut scm_i_thread,
        obj: SCM,
        m: *mut pthread_mutex_t,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_reset_sleep(arg1: *mut scm_i_thread);
}
extern "C" {
    pub fn scm_run_asyncs(list_of_a: SCM) -> SCM;
}
extern "C" {
    pub fn scm_noop(args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_with_blocked_asyncs(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_with_unblocked_asyncs(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_call_with_blocked_asyncs(
        p: ::std::option::Option<
            unsafe extern "C" fn(d: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        d: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_c_call_with_unblocked_asyncs(
        p: ::std::option::Option<
            unsafe extern "C" fn(d: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        d: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_dynwind_block_asyncs();
}
extern "C" {
    pub fn scm_dynwind_unblock_asyncs();
}
extern "C" {
    pub static mut scm_i_critical_section_mutex: pthread_mutex_t;
}
extern "C" {
    pub fn scm_critical_section_start();
}
extern "C" {
    pub fn scm_critical_section_end();
}
extern "C" {
    pub fn scm_init_async();
}
extern "C" {
    pub fn scm_system_async(thunk: SCM) -> SCM;
}
extern "C" {
    pub fn scm_unmask_signals() -> SCM;
}
extern "C" {
    pub fn scm_mask_signals() -> SCM;
}
extern "C" {
    pub fn scm_is_bool(arg1: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_to_bool(x: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_not(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_boolean_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_boolean();
}
extern "C" {
    #[doc = " Bit vectors"]
    pub fn scm_bitvector_p(vec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bitvector(bits: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_bitvector(len: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bitvector_length(vec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bitvector_ref(vec: SCM, idx: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bitvector_set_x(vec: SCM, idx: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_bitvector(list: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bitvector_to_list(vec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bitvector_fill_x(vec: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bit_count(item: SCM, seq: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bit_position(item: SCM, v: SCM, k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bit_set_star_x(v: SCM, kv: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bit_count_star(v: SCM, kv: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bit_invert_x(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_istr2bve(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_bitvector(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_make_bitvector(len: size_t, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_bitvector_length(vec: SCM) -> size_t;
}
extern "C" {
    pub fn scm_c_bitvector_ref(vec: SCM, idx: size_t) -> SCM;
}
extern "C" {
    pub fn scm_c_bitvector_set_x(vec: SCM, idx: size_t, val: SCM);
}
extern "C" {
    pub fn scm_array_handle_bit_elements(h: *mut scm_t_array_handle) -> *const scm_t_uint32;
}
extern "C" {
    pub fn scm_array_handle_bit_writable_elements(h: *mut scm_t_array_handle) -> *mut scm_t_uint32;
}
extern "C" {
    pub fn scm_array_handle_bit_elements_offset(h: *mut scm_t_array_handle) -> size_t;
}
extern "C" {
    pub fn scm_bitvector_elements(
        vec: SCM,
        h: *mut scm_t_array_handle,
        offp: *mut size_t,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *const scm_t_uint32;
}
extern "C" {
    pub fn scm_bitvector_writable_elements(
        vec: SCM,
        h: *mut scm_t_array_handle,
        offp: *mut size_t,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *mut scm_t_uint32;
}
extern "C" {
    pub fn scm_i_print_bitvector(
        vec: SCM,
        port: SCM,
        pstate: *mut scm_print_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_bitvector_equal_p(vec1: SCM, vec2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_bitvectors();
}
extern "C" {
    pub static mut scm_endianness_big: SCM;
}
extern "C" {
    pub static mut scm_endianness_little: SCM;
}
extern "C" {
    pub fn scm_c_make_bytevector(arg1: size_t) -> SCM;
}
extern "C" {
    pub fn scm_is_bytevector(arg1: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_bytevector_length(arg1: SCM) -> size_t;
}
extern "C" {
    pub fn scm_c_bytevector_ref(arg1: SCM, arg2: size_t) -> scm_t_uint8;
}
extern "C" {
    pub fn scm_c_bytevector_set_x(arg1: SCM, arg2: size_t, arg3: scm_t_uint8);
}
extern "C" {
    pub fn scm_make_bytevector(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_native_endianness() -> SCM;
}
extern "C" {
    pub fn scm_bytevector_p(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_length(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_eq_p(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_fill_x(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_copy_x(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM, arg5: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_copy(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_uniform_array_to_bytevector(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_to_u8_list(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u8_list_to_bytevector(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_uint_list_to_bytevector(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_to_uint_list(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sint_list_to_bytevector(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_to_sint_list(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u16_native_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s16_native_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u32_native_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s32_native_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u64_native_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s64_native_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u8_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s8_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_uint_ref(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_sint_ref(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u16_ref(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s16_ref(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u32_ref(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s32_ref(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u64_ref(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s64_ref(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u16_native_set_x(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s16_native_set_x(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u32_native_set_x(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s32_native_set_x(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u64_native_set_x(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s64_native_set_x(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u8_set_x(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s8_set_x(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_uint_set_x(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM, arg5: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_sint_set_x(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM, arg5: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u16_set_x(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s16_set_x(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u32_set_x(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s32_set_x(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u64_set_x(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s64_set_x(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_ieee_single_ref(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_ieee_single_native_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_ieee_single_set_x(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_ieee_single_native_set_x(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_ieee_double_ref(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_ieee_double_native_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_ieee_double_set_x(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_ieee_double_native_set_x(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_to_utf8(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_to_utf16(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_to_utf32(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_utf8_to_string(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_utf16_to_string(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_utf32_to_string(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_make_typed_bytevector(arg1: size_t, arg2: scm_t_array_element_type) -> SCM;
}
extern "C" {
    pub fn scm_c_take_typed_bytevector(
        arg1: *mut ::std::os::raw::c_schar,
        arg2: size_t,
        arg3: scm_t_array_element_type,
    ) -> SCM;
}
extern "C" {
    pub fn scm_bootstrap_bytevectors();
}
extern "C" {
    pub fn scm_init_bytevectors();
}
extern "C" {
    pub static mut scm_i_native_endianness: SCM;
}
extern "C" {
    pub fn scm_c_take_gc_bytevector(arg1: *mut ::std::os::raw::c_schar, arg2: size_t) -> SCM;
}
extern "C" {
    pub fn scm_i_print_bytevector(
        arg1: SCM,
        arg2: SCM,
        arg3: *mut scm_print_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_shrink_bytevector(arg1: SCM, arg2: size_t) -> SCM;
}
extern "C" {
    pub fn scm_i_bytevector_generalized_set_x(arg1: SCM, arg2: size_t, arg3: SCM);
}
extern "C" {
    pub static mut scm_null_bytevector: SCM;
}
extern "C" {
    pub fn scm_dynamic_link(fname: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynamic_unlink(dobj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynamic_object_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynamic_pointer(name: SCM, dobj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynamic_func(symb: SCM, dobj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynamic_call(symb: SCM, dobj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_dynamic_linking();
}
extern "C" {
    pub fn scm_eq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_eqv_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_equal_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_eq();
}
pub type scm_t_struct_finalize = ::std::option::Option<unsafe extern "C" fn(obj: SCM)>;
extern "C" {
    pub static mut scm_standard_vtable_vtable: SCM;
}
extern "C" {
    pub static mut scm_applicable_struct_vtable_vtable: SCM;
}
extern "C" {
    pub static mut scm_applicable_struct_with_setter_vtable_vtable: SCM;
}
extern "C" {
    pub fn scm_make_struct_layout(fields: SCM) -> SCM;
}
extern "C" {
    pub fn scm_struct_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_struct_vtable_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_struct(vtable: SCM, tail_array_size: SCM, init: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_make_struct(
        vtable: SCM,
        n_tail: size_t,
        n_inits: size_t,
        init: scm_t_bits,
        ...
    ) -> SCM;
}
extern "C" {
    pub fn scm_c_make_structv(
        vtable: SCM,
        n_tail: size_t,
        n_inits: size_t,
        init: *mut scm_t_bits,
    ) -> SCM;
}
extern "C" {
    pub fn scm_make_vtable(fields: SCM, printer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_make_vtable_vtable(extra_fields: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_vtable_vtable(extra_fields: SCM, tail_array_size: SCM, init: SCM) -> SCM;
}
extern "C" {
    pub fn scm_struct_ref(handle: SCM, pos: SCM) -> SCM;
}
extern "C" {
    pub fn scm_struct_set_x(handle: SCM, pos: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_struct_vtable(handle: SCM) -> SCM;
}
extern "C" {
    pub fn scm_struct_vtable_name(vtable: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_struct_vtable_name_x(vtable: SCM, name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_print_struct(exp: SCM, port: SCM, arg1: *mut scm_print_state);
}
extern "C" {
    pub fn scm_i_struct_equalp(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_struct_ihashq(
        arg1: SCM,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_i_struct_hash(
        s: SCM,
        n: ::std::os::raw::c_ulong,
        depth: size_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_i_alloc_struct(vtable_data: *mut scm_t_bits, n_words: ::std::os::raw::c_int) -> SCM;
}
extern "C" {
    pub fn scm_i_struct_inherit_vtable_magic(vtable: SCM, obj: SCM);
}
extern "C" {
    pub fn scm_init_struct();
}
extern "C" {
    pub static mut scm_sym_and: SCM;
}
extern "C" {
    pub static mut scm_sym_begin: SCM;
}
extern "C" {
    pub static mut scm_sym_case: SCM;
}
extern "C" {
    pub static mut scm_sym_cond: SCM;
}
extern "C" {
    pub static mut scm_sym_define: SCM;
}
extern "C" {
    pub static mut scm_sym_do: SCM;
}
extern "C" {
    pub static mut scm_sym_if: SCM;
}
extern "C" {
    pub static mut scm_sym_lambda: SCM;
}
extern "C" {
    pub static mut scm_sym_let: SCM;
}
extern "C" {
    pub static mut scm_sym_letstar: SCM;
}
extern "C" {
    pub static mut scm_sym_letrec: SCM;
}
extern "C" {
    pub static mut scm_sym_quote: SCM;
}
extern "C" {
    pub static mut scm_sym_quasiquote: SCM;
}
extern "C" {
    pub static mut scm_sym_unquote: SCM;
}
extern "C" {
    pub static mut scm_sym_uq_splicing: SCM;
}
extern "C" {
    pub static mut scm_sym_with_fluids: SCM;
}
extern "C" {
    pub static mut scm_sym_at: SCM;
}
extern "C" {
    pub static mut scm_sym_atat: SCM;
}
extern "C" {
    pub static mut scm_sym_atapply: SCM;
}
extern "C" {
    pub static mut scm_sym_atcall_cc: SCM;
}
extern "C" {
    pub static mut scm_sym_at_call_with_values: SCM;
}
extern "C" {
    pub static mut scm_sym_at_prompt: SCM;
}
extern "C" {
    pub static mut scm_sym_delay: SCM;
}
extern "C" {
    pub static mut scm_sym_at_dynamic_wind: SCM;
}
extern "C" {
    pub static mut scm_sym_eval_when: SCM;
}
extern "C" {
    pub static mut scm_sym_arrow: SCM;
}
extern "C" {
    pub static mut scm_sym_else: SCM;
}
extern "C" {
    pub static mut scm_sym_apply: SCM;
}
extern "C" {
    pub static mut scm_sym_set_x: SCM;
}
extern "C" {
    pub static mut scm_sym_args: SCM;
}
extern "C" {
    pub static mut scm_tc16_memoized: scm_t_bits;
}
pub const SCM_M_BEGIN: ::std::os::raw::c_uint = 0;
pub const SCM_M_IF: ::std::os::raw::c_uint = 1;
pub const SCM_M_LAMBDA: ::std::os::raw::c_uint = 2;
pub const SCM_M_LET: ::std::os::raw::c_uint = 3;
pub const SCM_M_QUOTE: ::std::os::raw::c_uint = 4;
pub const SCM_M_DEFINE: ::std::os::raw::c_uint = 5;
pub const SCM_M_DYNWIND: ::std::os::raw::c_uint = 6;
pub const SCM_M_WITH_FLUIDS: ::std::os::raw::c_uint = 7;
pub const SCM_M_APPLY: ::std::os::raw::c_uint = 8;
pub const SCM_M_CONT: ::std::os::raw::c_uint = 9;
pub const SCM_M_CALL_WITH_VALUES: ::std::os::raw::c_uint = 10;
pub const SCM_M_CALL: ::std::os::raw::c_uint = 11;
pub const SCM_M_LEXICAL_REF: ::std::os::raw::c_uint = 12;
pub const SCM_M_LEXICAL_SET: ::std::os::raw::c_uint = 13;
pub const SCM_M_TOPLEVEL_REF: ::std::os::raw::c_uint = 14;
pub const SCM_M_TOPLEVEL_SET: ::std::os::raw::c_uint = 15;
pub const SCM_M_MODULE_REF: ::std::os::raw::c_uint = 16;
pub const SCM_M_MODULE_SET: ::std::os::raw::c_uint = 17;
pub const SCM_M_PROMPT: ::std::os::raw::c_uint = 18;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
extern "C" {
    pub fn scm_memoize_expression(exp: SCM) -> SCM;
}
extern "C" {
    pub fn scm_unmemoize_expression(memoized: SCM) -> SCM;
}
extern "C" {
    pub fn scm_memoized_expression_typecode(memoized: SCM) -> SCM;
}
extern "C" {
    pub fn scm_memoized_expression_data(memoized: SCM) -> SCM;
}
extern "C" {
    pub fn scm_memoized_typecode(sym: SCM) -> SCM;
}
extern "C" {
    pub fn scm_memoize_variable_access_x(memoized: SCM, module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_memoized_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_memoize();
}
pub type scm_t_trampoline_0 = ::std::option::Option<unsafe extern "C" fn(proc_: SCM) -> SCM>;
pub type scm_t_trampoline_1 =
    ::std::option::Option<unsafe extern "C" fn(proc_: SCM, arg1: SCM) -> SCM>;
pub type scm_t_trampoline_2 =
    ::std::option::Option<unsafe extern "C" fn(proc_: SCM, arg1: SCM, arg2: SCM) -> SCM>;
extern "C" {
    pub fn scm_call_0(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_1(proc_: SCM, arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_2(proc_: SCM, arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_3(proc_: SCM, arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_4(proc_: SCM, arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_5(proc_: SCM, arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM, arg5: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_6(
        proc_: SCM,
        arg1: SCM,
        arg2: SCM,
        arg3: SCM,
        arg4: SCM,
        arg5: SCM,
        arg6: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_call_7(
        proc_: SCM,
        arg1: SCM,
        arg2: SCM,
        arg3: SCM,
        arg4: SCM,
        arg5: SCM,
        arg6: SCM,
        arg7: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_call_8(
        proc_: SCM,
        arg1: SCM,
        arg2: SCM,
        arg3: SCM,
        arg4: SCM,
        arg5: SCM,
        arg6: SCM,
        arg7: SCM,
        arg8: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_call_9(
        proc_: SCM,
        arg1: SCM,
        arg2: SCM,
        arg3: SCM,
        arg4: SCM,
        arg5: SCM,
        arg6: SCM,
        arg7: SCM,
        arg8: SCM,
        arg9: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_call_n(proc_: SCM, argv: *mut SCM, nargs: size_t) -> SCM;
}
extern "C" {
    pub fn scm_call(proc_: SCM, ...) -> SCM;
}
extern "C" {
    pub fn scm_apply_0(proc_: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_apply_1(proc_: SCM, arg1: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_apply_2(proc_: SCM, arg1: SCM, arg2: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_apply_3(proc_: SCM, arg1: SCM, arg2: SCM, arg3: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_nconc2last(lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_apply(proc_: SCM, arg1: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_map(proc_: SCM, arg1: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_for_each(proc_: SCM, arg1: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_eval(exp: SCM) -> SCM;
}
extern "C" {
    pub fn scm_eval(exp: SCM, module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_eval();
}
extern "C" {
    pub fn scm_defined_p(sym: SCM, env: SCM) -> SCM;
}
extern "C" {
    pub fn scm_self_evaluating_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_evalext();
}
pub type scm_t_extension_init_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn scm_c_register_extension(
        lib: *const ::std::os::raw::c_char,
        init: *const ::std::os::raw::c_char,
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn scm_c_load_extension(
        lib: *const ::std::os::raw::c_char,
        init: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn scm_load_extension(lib: SCM, init: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_extensions();
}
extern "C" {
    pub fn scm_add_feature(str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_program_arguments() -> SCM;
}
extern "C" {
    pub fn scm_set_program_arguments(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        first: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn scm_set_program_arguments_scm(lst: SCM) -> SCM;
}
extern "C" {
    pub static mut scm_program_arguments_fluid: SCM;
}
extern "C" {
    pub fn scm_init_feature();
}
extern "C" {
    pub static mut scm_tc16_dir: scm_t_bits;
}
extern "C" {
    pub fn scm_chown(object: SCM, owner: SCM, group: SCM) -> SCM;
}
extern "C" {
    pub fn scm_chmod(object: SCM, mode: SCM) -> SCM;
}
extern "C" {
    pub fn scm_umask(mode: SCM) -> SCM;
}
extern "C" {
    pub fn scm_open_fdes(path: SCM, flags: SCM, mode: SCM) -> SCM;
}
extern "C" {
    pub fn scm_open(path: SCM, flags: SCM, mode: SCM) -> SCM;
}
extern "C" {
    pub fn scm_close(fd_or_port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_close_fdes(fd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_stat(object: SCM, exception_on_error: SCM) -> SCM;
}
extern "C" {
    pub fn scm_link(oldpath: SCM, newpath: SCM) -> SCM;
}
extern "C" {
    pub fn scm_rename(oldname: SCM, newname: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delete_file(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_mkdir(path: SCM, mode: SCM) -> SCM;
}
extern "C" {
    pub fn scm_rmdir(path: SCM) -> SCM;
}
extern "C" {
    pub fn scm_directory_stream_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_opendir(dirname: SCM) -> SCM;
}
extern "C" {
    pub fn scm_readdir(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_rewinddir(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_closedir(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_chdir(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getcwd() -> SCM;
}
extern "C" {
    pub fn scm_select(reads: SCM, writes: SCM, excepts: SCM, secs: SCM, msecs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fcntl(object: SCM, cmd: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fsync(object: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symlink(oldpath: SCM, newpath: SCM) -> SCM;
}
extern "C" {
    pub fn scm_readlink(path: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lstat(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_copy_file(oldfile: SCM, newfile: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dirname(filename: SCM) -> SCM;
}
extern "C" {
    pub fn scm_basename(filename: SCM, suffix: SCM) -> SCM;
}
extern "C" {
    pub fn scm_canonicalize_path(path: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sendfile(out: SCM, in_: SCM, count: SCM, offset: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_relativize_path(path: SCM, in_path: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_filesys();
}
pub type scm_t_finalizer_proc = ::std::option::Option<
    unsafe extern "C" fn(obj: *mut ::std::os::raw::c_void, data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn scm_i_set_finalizer(
        obj: *mut ::std::os::raw::c_void,
        arg1: scm_t_finalizer_proc,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn scm_i_add_finalizer(
        obj: *mut ::std::os::raw::c_void,
        arg1: scm_t_finalizer_proc,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn scm_i_add_resuscitator(
        obj: *mut ::std::os::raw::c_void,
        arg1: scm_t_finalizer_proc,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn scm_set_automatic_finalization_enabled(
        enabled_p: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_run_finalizers() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_init_finalizers();
}
extern "C" {
    pub fn scm_vector_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_vector_length(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_vector_ref(v: SCM, k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_vector_set_x(v: SCM, k: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_vector(k: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_vector_to_list(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_vector_fill_x(v: SCM, fill_x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_vector_move_left_x(vec1: SCM, start1: SCM, end1: SCM, vec2: SCM, start2: SCM)
        -> SCM;
}
extern "C" {
    pub fn scm_vector_move_right_x(
        vec1: SCM,
        start1: SCM,
        end1: SCM,
        vec2: SCM,
        start2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_vector_copy(vec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_vector(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_is_simple_vector(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_make_vector(len: size_t, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_vector_length(vec: SCM) -> size_t;
}
extern "C" {
    pub fn scm_c_vector_ref(vec: SCM, k: size_t) -> SCM;
}
extern "C" {
    pub fn scm_c_vector_set_x(vec: SCM, k: size_t, obj: SCM);
}
extern "C" {
    pub fn scm_vector_elements(
        vec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *const SCM;
}
extern "C" {
    pub fn scm_vector_writable_elements(
        vec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *mut SCM;
}
extern "C" {
    pub fn scm_i_vector_equal_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_make_weak_vector(type_: scm_t_bits, size: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_make_weak_vector_from_list(type_: scm_t_bits, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_vectors();
}
extern "C" {
    pub fn scm_make_fluid() -> SCM;
}
extern "C" {
    pub fn scm_make_fluid_with_default(dflt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_unbound_fluid() -> SCM;
}
extern "C" {
    pub fn scm_is_fluid(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_fluid_p(fl: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fluid_ref(fluid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fluid_set_x(fluid: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fluid_unset_x(fluid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fluid_bound_p(fluid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_make_with_fluids(n: size_t, fluids: *mut SCM, vals: *mut SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_swap_with_fluids(with_fluids: SCM, dynamic_state: SCM);
}
extern "C" {
    pub fn scm_c_with_fluids(
        fluids: SCM,
        vals: SCM,
        cproc: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> SCM,
        >,
        cdata: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_c_with_fluid(
        fluid: SCM,
        val: SCM,
        cproc: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> SCM,
        >,
        cdata: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_with_fluids(fluids: SCM, vals: SCM, thunk: SCM) -> SCM;
}
extern "C" {
    pub fn scm_with_fluid(fluid: SCM, val: SCM, thunk: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynwind_fluid(fluid: SCM, value: SCM);
}
extern "C" {
    pub fn scm_make_dynamic_state(parent: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynamic_state_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_dynamic_state(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_current_dynamic_state() -> SCM;
}
extern "C" {
    pub fn scm_set_current_dynamic_state(state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynwind_current_dynamic_state(state: SCM);
}
extern "C" {
    pub fn scm_c_with_dynamic_state(
        state: SCM,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_with_dynamic_state(state: SCM, proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_make_initial_dynamic_state() -> SCM;
}
extern "C" {
    pub fn scm_i_fluid_print(exp: SCM, port: SCM, pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_i_dynamic_state_print(exp: SCM, port: SCM, pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_i_with_fluids_print(exp: SCM, port: SCM, pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_init_fluids();
}
pub const scm_t_foreign_type_SCM_FOREIGN_TYPE_VOID: scm_t_foreign_type = 0;
pub const scm_t_foreign_type_SCM_FOREIGN_TYPE_FLOAT: scm_t_foreign_type = 1;
pub const scm_t_foreign_type_SCM_FOREIGN_TYPE_DOUBLE: scm_t_foreign_type = 2;
pub const scm_t_foreign_type_SCM_FOREIGN_TYPE_UINT8: scm_t_foreign_type = 3;
pub const scm_t_foreign_type_SCM_FOREIGN_TYPE_INT8: scm_t_foreign_type = 4;
pub const scm_t_foreign_type_SCM_FOREIGN_TYPE_UINT16: scm_t_foreign_type = 5;
pub const scm_t_foreign_type_SCM_FOREIGN_TYPE_INT16: scm_t_foreign_type = 6;
pub const scm_t_foreign_type_SCM_FOREIGN_TYPE_UINT32: scm_t_foreign_type = 7;
pub const scm_t_foreign_type_SCM_FOREIGN_TYPE_INT32: scm_t_foreign_type = 8;
pub const scm_t_foreign_type_SCM_FOREIGN_TYPE_UINT64: scm_t_foreign_type = 9;
pub const scm_t_foreign_type_SCM_FOREIGN_TYPE_INT64: scm_t_foreign_type = 10;
pub const scm_t_foreign_type_SCM_FOREIGN_TYPE_LAST: scm_t_foreign_type = 10;
pub type scm_t_foreign_type = ::std::os::raw::c_uint;
pub type scm_t_pointer_finalizer =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn scm_to_pointer(pointer: SCM) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_from_pointer(
        arg1: *mut ::std::os::raw::c_void,
        arg2: scm_t_pointer_finalizer,
    ) -> SCM;
}
extern "C" {
    pub fn scm_alignof(type_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sizeof(type_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pointer_address(pointer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pointer_to_bytevector(pointer: SCM, type_: SCM, offset: SCM, len: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_pointer_finalizer_x(pointer: SCM, finalizer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_to_pointer(bv: SCM, offset: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pointer_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_pointer(address: SCM, finalizer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_pointer_print(pointer: SCM, port: SCM, pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_dereference_pointer(pointer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_to_pointer(string: SCM, encoding: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pointer_to_string(pointer: SCM, length: SCM, encoding: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pointer_to_procedure(return_type: SCM, func_ptr: SCM, arg_types: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pointer_to_procedure_with_errno(
        return_type: SCM,
        func_ptr: SCM,
        arg_types: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_procedure_to_pointer(return_type: SCM, func_ptr: SCM, arg_types: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_foreign_call(foreign: SCM, argv: *const SCM) -> SCM;
}
extern "C" {
    pub fn scm_register_foreign();
}
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn closefrom(__lowfd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: size_t,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(
        __buf: *mut ::std::os::raw::c_char,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int);
}
pub const _PC_LINK_MAX: ::std::os::raw::c_uint = 0;
pub const _PC_MAX_CANON: ::std::os::raw::c_uint = 1;
pub const _PC_MAX_INPUT: ::std::os::raw::c_uint = 2;
pub const _PC_NAME_MAX: ::std::os::raw::c_uint = 3;
pub const _PC_PATH_MAX: ::std::os::raw::c_uint = 4;
pub const _PC_PIPE_BUF: ::std::os::raw::c_uint = 5;
pub const _PC_CHOWN_RESTRICTED: ::std::os::raw::c_uint = 6;
pub const _PC_NO_TRUNC: ::std::os::raw::c_uint = 7;
pub const _PC_VDISABLE: ::std::os::raw::c_uint = 8;
pub const _PC_SYNC_IO: ::std::os::raw::c_uint = 9;
pub const _PC_ASYNC_IO: ::std::os::raw::c_uint = 10;
pub const _PC_PRIO_IO: ::std::os::raw::c_uint = 11;
pub const _PC_SOCK_MAXBUF: ::std::os::raw::c_uint = 12;
pub const _PC_FILESIZEBITS: ::std::os::raw::c_uint = 13;
pub const _PC_REC_INCR_XFER_SIZE: ::std::os::raw::c_uint = 14;
pub const _PC_REC_MAX_XFER_SIZE: ::std::os::raw::c_uint = 15;
pub const _PC_REC_MIN_XFER_SIZE: ::std::os::raw::c_uint = 16;
pub const _PC_REC_XFER_ALIGN: ::std::os::raw::c_uint = 17;
pub const _PC_ALLOC_SIZE_MIN: ::std::os::raw::c_uint = 18;
pub const _PC_SYMLINK_MAX: ::std::os::raw::c_uint = 19;
pub const _PC_2_SYMLINKS: ::std::os::raw::c_uint = 20;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: ::std::os::raw::c_uint = 0;
pub const _SC_CHILD_MAX: ::std::os::raw::c_uint = 1;
pub const _SC_CLK_TCK: ::std::os::raw::c_uint = 2;
pub const _SC_NGROUPS_MAX: ::std::os::raw::c_uint = 3;
pub const _SC_OPEN_MAX: ::std::os::raw::c_uint = 4;
pub const _SC_STREAM_MAX: ::std::os::raw::c_uint = 5;
pub const _SC_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _SC_JOB_CONTROL: ::std::os::raw::c_uint = 7;
pub const _SC_SAVED_IDS: ::std::os::raw::c_uint = 8;
pub const _SC_REALTIME_SIGNALS: ::std::os::raw::c_uint = 9;
pub const _SC_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 10;
pub const _SC_TIMERS: ::std::os::raw::c_uint = 11;
pub const _SC_ASYNCHRONOUS_IO: ::std::os::raw::c_uint = 12;
pub const _SC_PRIORITIZED_IO: ::std::os::raw::c_uint = 13;
pub const _SC_SYNCHRONIZED_IO: ::std::os::raw::c_uint = 14;
pub const _SC_FSYNC: ::std::os::raw::c_uint = 15;
pub const _SC_MAPPED_FILES: ::std::os::raw::c_uint = 16;
pub const _SC_MEMLOCK: ::std::os::raw::c_uint = 17;
pub const _SC_MEMLOCK_RANGE: ::std::os::raw::c_uint = 18;
pub const _SC_MEMORY_PROTECTION: ::std::os::raw::c_uint = 19;
pub const _SC_MESSAGE_PASSING: ::std::os::raw::c_uint = 20;
pub const _SC_SEMAPHORES: ::std::os::raw::c_uint = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: ::std::os::raw::c_uint = 22;
pub const _SC_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 23;
pub const _SC_AIO_MAX: ::std::os::raw::c_uint = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: ::std::os::raw::c_uint = 25;
pub const _SC_DELAYTIMER_MAX: ::std::os::raw::c_uint = 26;
pub const _SC_MQ_OPEN_MAX: ::std::os::raw::c_uint = 27;
pub const _SC_MQ_PRIO_MAX: ::std::os::raw::c_uint = 28;
pub const _SC_VERSION: ::std::os::raw::c_uint = 29;
pub const _SC_PAGESIZE: ::std::os::raw::c_uint = 30;
pub const _SC_RTSIG_MAX: ::std::os::raw::c_uint = 31;
pub const _SC_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 32;
pub const _SC_SEM_VALUE_MAX: ::std::os::raw::c_uint = 33;
pub const _SC_SIGQUEUE_MAX: ::std::os::raw::c_uint = 34;
pub const _SC_TIMER_MAX: ::std::os::raw::c_uint = 35;
pub const _SC_BC_BASE_MAX: ::std::os::raw::c_uint = 36;
pub const _SC_BC_DIM_MAX: ::std::os::raw::c_uint = 37;
pub const _SC_BC_SCALE_MAX: ::std::os::raw::c_uint = 38;
pub const _SC_BC_STRING_MAX: ::std::os::raw::c_uint = 39;
pub const _SC_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 40;
pub const _SC_EQUIV_CLASS_MAX: ::std::os::raw::c_uint = 41;
pub const _SC_EXPR_NEST_MAX: ::std::os::raw::c_uint = 42;
pub const _SC_LINE_MAX: ::std::os::raw::c_uint = 43;
pub const _SC_RE_DUP_MAX: ::std::os::raw::c_uint = 44;
pub const _SC_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 45;
pub const _SC_2_VERSION: ::std::os::raw::c_uint = 46;
pub const _SC_2_C_BIND: ::std::os::raw::c_uint = 47;
pub const _SC_2_C_DEV: ::std::os::raw::c_uint = 48;
pub const _SC_2_FORT_DEV: ::std::os::raw::c_uint = 49;
pub const _SC_2_FORT_RUN: ::std::os::raw::c_uint = 50;
pub const _SC_2_SW_DEV: ::std::os::raw::c_uint = 51;
pub const _SC_2_LOCALEDEF: ::std::os::raw::c_uint = 52;
pub const _SC_PII: ::std::os::raw::c_uint = 53;
pub const _SC_PII_XTI: ::std::os::raw::c_uint = 54;
pub const _SC_PII_SOCKET: ::std::os::raw::c_uint = 55;
pub const _SC_PII_INTERNET: ::std::os::raw::c_uint = 56;
pub const _SC_PII_OSI: ::std::os::raw::c_uint = 57;
pub const _SC_POLL: ::std::os::raw::c_uint = 58;
pub const _SC_SELECT: ::std::os::raw::c_uint = 59;
pub const _SC_UIO_MAXIOV: ::std::os::raw::c_uint = 60;
pub const _SC_IOV_MAX: ::std::os::raw::c_uint = 60;
pub const _SC_PII_INTERNET_STREAM: ::std::os::raw::c_uint = 61;
pub const _SC_PII_INTERNET_DGRAM: ::std::os::raw::c_uint = 62;
pub const _SC_PII_OSI_COTS: ::std::os::raw::c_uint = 63;
pub const _SC_PII_OSI_CLTS: ::std::os::raw::c_uint = 64;
pub const _SC_PII_OSI_M: ::std::os::raw::c_uint = 65;
pub const _SC_T_IOV_MAX: ::std::os::raw::c_uint = 66;
pub const _SC_THREADS: ::std::os::raw::c_uint = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: ::std::os::raw::c_uint = 68;
pub const _SC_GETGR_R_SIZE_MAX: ::std::os::raw::c_uint = 69;
pub const _SC_GETPW_R_SIZE_MAX: ::std::os::raw::c_uint = 70;
pub const _SC_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 71;
pub const _SC_TTY_NAME_MAX: ::std::os::raw::c_uint = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 73;
pub const _SC_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 74;
pub const _SC_THREAD_STACK_MIN: ::std::os::raw::c_uint = 75;
pub const _SC_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 76;
pub const _SC_THREAD_ATTR_STACKADDR: ::std::os::raw::c_uint = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: ::std::os::raw::c_uint = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 79;
pub const _SC_THREAD_PRIO_INHERIT: ::std::os::raw::c_uint = 80;
pub const _SC_THREAD_PRIO_PROTECT: ::std::os::raw::c_uint = 81;
pub const _SC_THREAD_PROCESS_SHARED: ::std::os::raw::c_uint = 82;
pub const _SC_NPROCESSORS_CONF: ::std::os::raw::c_uint = 83;
pub const _SC_NPROCESSORS_ONLN: ::std::os::raw::c_uint = 84;
pub const _SC_PHYS_PAGES: ::std::os::raw::c_uint = 85;
pub const _SC_AVPHYS_PAGES: ::std::os::raw::c_uint = 86;
pub const _SC_ATEXIT_MAX: ::std::os::raw::c_uint = 87;
pub const _SC_PASS_MAX: ::std::os::raw::c_uint = 88;
pub const _SC_XOPEN_VERSION: ::std::os::raw::c_uint = 89;
pub const _SC_XOPEN_XCU_VERSION: ::std::os::raw::c_uint = 90;
pub const _SC_XOPEN_UNIX: ::std::os::raw::c_uint = 91;
pub const _SC_XOPEN_CRYPT: ::std::os::raw::c_uint = 92;
pub const _SC_XOPEN_ENH_I18N: ::std::os::raw::c_uint = 93;
pub const _SC_XOPEN_SHM: ::std::os::raw::c_uint = 94;
pub const _SC_2_CHAR_TERM: ::std::os::raw::c_uint = 95;
pub const _SC_2_C_VERSION: ::std::os::raw::c_uint = 96;
pub const _SC_2_UPE: ::std::os::raw::c_uint = 97;
pub const _SC_XOPEN_XPG2: ::std::os::raw::c_uint = 98;
pub const _SC_XOPEN_XPG3: ::std::os::raw::c_uint = 99;
pub const _SC_XOPEN_XPG4: ::std::os::raw::c_uint = 100;
pub const _SC_CHAR_BIT: ::std::os::raw::c_uint = 101;
pub const _SC_CHAR_MAX: ::std::os::raw::c_uint = 102;
pub const _SC_CHAR_MIN: ::std::os::raw::c_uint = 103;
pub const _SC_INT_MAX: ::std::os::raw::c_uint = 104;
pub const _SC_INT_MIN: ::std::os::raw::c_uint = 105;
pub const _SC_LONG_BIT: ::std::os::raw::c_uint = 106;
pub const _SC_WORD_BIT: ::std::os::raw::c_uint = 107;
pub const _SC_MB_LEN_MAX: ::std::os::raw::c_uint = 108;
pub const _SC_NZERO: ::std::os::raw::c_uint = 109;
pub const _SC_SSIZE_MAX: ::std::os::raw::c_uint = 110;
pub const _SC_SCHAR_MAX: ::std::os::raw::c_uint = 111;
pub const _SC_SCHAR_MIN: ::std::os::raw::c_uint = 112;
pub const _SC_SHRT_MAX: ::std::os::raw::c_uint = 113;
pub const _SC_SHRT_MIN: ::std::os::raw::c_uint = 114;
pub const _SC_UCHAR_MAX: ::std::os::raw::c_uint = 115;
pub const _SC_UINT_MAX: ::std::os::raw::c_uint = 116;
pub const _SC_ULONG_MAX: ::std::os::raw::c_uint = 117;
pub const _SC_USHRT_MAX: ::std::os::raw::c_uint = 118;
pub const _SC_NL_ARGMAX: ::std::os::raw::c_uint = 119;
pub const _SC_NL_LANGMAX: ::std::os::raw::c_uint = 120;
pub const _SC_NL_MSGMAX: ::std::os::raw::c_uint = 121;
pub const _SC_NL_NMAX: ::std::os::raw::c_uint = 122;
pub const _SC_NL_SETMAX: ::std::os::raw::c_uint = 123;
pub const _SC_NL_TEXTMAX: ::std::os::raw::c_uint = 124;
pub const _SC_XBS5_ILP32_OFF32: ::std::os::raw::c_uint = 125;
pub const _SC_XBS5_ILP32_OFFBIG: ::std::os::raw::c_uint = 126;
pub const _SC_XBS5_LP64_OFF64: ::std::os::raw::c_uint = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: ::std::os::raw::c_uint = 128;
pub const _SC_XOPEN_LEGACY: ::std::os::raw::c_uint = 129;
pub const _SC_XOPEN_REALTIME: ::std::os::raw::c_uint = 130;
pub const _SC_XOPEN_REALTIME_THREADS: ::std::os::raw::c_uint = 131;
pub const _SC_ADVISORY_INFO: ::std::os::raw::c_uint = 132;
pub const _SC_BARRIERS: ::std::os::raw::c_uint = 133;
pub const _SC_BASE: ::std::os::raw::c_uint = 134;
pub const _SC_C_LANG_SUPPORT: ::std::os::raw::c_uint = 135;
pub const _SC_C_LANG_SUPPORT_R: ::std::os::raw::c_uint = 136;
pub const _SC_CLOCK_SELECTION: ::std::os::raw::c_uint = 137;
pub const _SC_CPUTIME: ::std::os::raw::c_uint = 138;
pub const _SC_THREAD_CPUTIME: ::std::os::raw::c_uint = 139;
pub const _SC_DEVICE_IO: ::std::os::raw::c_uint = 140;
pub const _SC_DEVICE_SPECIFIC: ::std::os::raw::c_uint = 141;
pub const _SC_DEVICE_SPECIFIC_R: ::std::os::raw::c_uint = 142;
pub const _SC_FD_MGMT: ::std::os::raw::c_uint = 143;
pub const _SC_FIFO: ::std::os::raw::c_uint = 144;
pub const _SC_PIPE: ::std::os::raw::c_uint = 145;
pub const _SC_FILE_ATTRIBUTES: ::std::os::raw::c_uint = 146;
pub const _SC_FILE_LOCKING: ::std::os::raw::c_uint = 147;
pub const _SC_FILE_SYSTEM: ::std::os::raw::c_uint = 148;
pub const _SC_MONOTONIC_CLOCK: ::std::os::raw::c_uint = 149;
pub const _SC_MULTI_PROCESS: ::std::os::raw::c_uint = 150;
pub const _SC_SINGLE_PROCESS: ::std::os::raw::c_uint = 151;
pub const _SC_NETWORKING: ::std::os::raw::c_uint = 152;
pub const _SC_READER_WRITER_LOCKS: ::std::os::raw::c_uint = 153;
pub const _SC_SPIN_LOCKS: ::std::os::raw::c_uint = 154;
pub const _SC_REGEXP: ::std::os::raw::c_uint = 155;
pub const _SC_REGEX_VERSION: ::std::os::raw::c_uint = 156;
pub const _SC_SHELL: ::std::os::raw::c_uint = 157;
pub const _SC_SIGNALS: ::std::os::raw::c_uint = 158;
pub const _SC_SPAWN: ::std::os::raw::c_uint = 159;
pub const _SC_SPORADIC_SERVER: ::std::os::raw::c_uint = 160;
pub const _SC_THREAD_SPORADIC_SERVER: ::std::os::raw::c_uint = 161;
pub const _SC_SYSTEM_DATABASE: ::std::os::raw::c_uint = 162;
pub const _SC_SYSTEM_DATABASE_R: ::std::os::raw::c_uint = 163;
pub const _SC_TIMEOUTS: ::std::os::raw::c_uint = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: ::std::os::raw::c_uint = 165;
pub const _SC_USER_GROUPS: ::std::os::raw::c_uint = 166;
pub const _SC_USER_GROUPS_R: ::std::os::raw::c_uint = 167;
pub const _SC_2_PBS: ::std::os::raw::c_uint = 168;
pub const _SC_2_PBS_ACCOUNTING: ::std::os::raw::c_uint = 169;
pub const _SC_2_PBS_LOCATE: ::std::os::raw::c_uint = 170;
pub const _SC_2_PBS_MESSAGE: ::std::os::raw::c_uint = 171;
pub const _SC_2_PBS_TRACK: ::std::os::raw::c_uint = 172;
pub const _SC_SYMLOOP_MAX: ::std::os::raw::c_uint = 173;
pub const _SC_STREAMS: ::std::os::raw::c_uint = 174;
pub const _SC_2_PBS_CHECKPOINT: ::std::os::raw::c_uint = 175;
pub const _SC_V6_ILP32_OFF32: ::std::os::raw::c_uint = 176;
pub const _SC_V6_ILP32_OFFBIG: ::std::os::raw::c_uint = 177;
pub const _SC_V6_LP64_OFF64: ::std::os::raw::c_uint = 178;
pub const _SC_V6_LPBIG_OFFBIG: ::std::os::raw::c_uint = 179;
pub const _SC_HOST_NAME_MAX: ::std::os::raw::c_uint = 180;
pub const _SC_TRACE: ::std::os::raw::c_uint = 181;
pub const _SC_TRACE_EVENT_FILTER: ::std::os::raw::c_uint = 182;
pub const _SC_TRACE_INHERIT: ::std::os::raw::c_uint = 183;
pub const _SC_TRACE_LOG: ::std::os::raw::c_uint = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: ::std::os::raw::c_uint = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: ::std::os::raw::c_uint = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: ::std::os::raw::c_uint = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: ::std::os::raw::c_uint = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: ::std::os::raw::c_uint = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: ::std::os::raw::c_uint = 190;
pub const _SC_LEVEL2_CACHE_SIZE: ::std::os::raw::c_uint = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: ::std::os::raw::c_uint = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: ::std::os::raw::c_uint = 193;
pub const _SC_LEVEL3_CACHE_SIZE: ::std::os::raw::c_uint = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: ::std::os::raw::c_uint = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: ::std::os::raw::c_uint = 196;
pub const _SC_LEVEL4_CACHE_SIZE: ::std::os::raw::c_uint = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: ::std::os::raw::c_uint = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: ::std::os::raw::c_uint = 199;
pub const _SC_IPV6: ::std::os::raw::c_uint = 235;
pub const _SC_RAW_SOCKETS: ::std::os::raw::c_uint = 236;
pub const _SC_V7_ILP32_OFF32: ::std::os::raw::c_uint = 237;
pub const _SC_V7_ILP32_OFFBIG: ::std::os::raw::c_uint = 238;
pub const _SC_V7_LP64_OFF64: ::std::os::raw::c_uint = 239;
pub const _SC_V7_LPBIG_OFFBIG: ::std::os::raw::c_uint = 240;
pub const _SC_SS_REPL_MAX: ::std::os::raw::c_uint = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: ::std::os::raw::c_uint = 242;
pub const _SC_TRACE_NAME_MAX: ::std::os::raw::c_uint = 243;
pub const _SC_TRACE_SYS_MAX: ::std::os::raw::c_uint = 244;
pub const _SC_TRACE_USER_EVENT_MAX: ::std::os::raw::c_uint = 245;
pub const _SC_XOPEN_STREAMS: ::std::os::raw::c_uint = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::std::os::raw::c_uint = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::std::os::raw::c_uint = 248;
pub const _SC_MINSIGSTKSZ: ::std::os::raw::c_uint = 249;
pub const _SC_SIGSTKSZ: ::std::os::raw::c_uint = 250;
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
pub const _CS_PATH: ::std::os::raw::c_uint = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: ::std::os::raw::c_uint = 1;
pub const _CS_GNU_LIBC_VERSION: ::std::os::raw::c_uint = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: ::std::os::raw::c_uint = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: ::std::os::raw::c_uint = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: ::std::os::raw::c_uint = 5;
pub const _CS_LFS_CFLAGS: ::std::os::raw::c_uint = 1000;
pub const _CS_LFS_LDFLAGS: ::std::os::raw::c_uint = 1001;
pub const _CS_LFS_LIBS: ::std::os::raw::c_uint = 1002;
pub const _CS_LFS_LINTFLAGS: ::std::os::raw::c_uint = 1003;
pub const _CS_LFS64_CFLAGS: ::std::os::raw::c_uint = 1004;
pub const _CS_LFS64_LDFLAGS: ::std::os::raw::c_uint = 1005;
pub const _CS_LFS64_LIBS: ::std::os::raw::c_uint = 1006;
pub const _CS_LFS64_LINTFLAGS: ::std::os::raw::c_uint = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: ::std::os::raw::c_uint = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: ::std::os::raw::c_uint = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: ::std::os::raw::c_uint = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: ::std::os::raw::c_uint = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: ::std::os::raw::c_uint = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: ::std::os::raw::c_uint = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1147;
pub const _CS_V6_ENV: ::std::os::raw::c_uint = 1148;
pub const _CS_V7_ENV: ::std::os::raw::c_uint = 1149;
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: size_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: size_t,
        __offset: size_t,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        __key: *const ::std::os::raw::c_char,
        __salt: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __length: size_t,
    ) -> ::std::os::raw::c_int;
}
pub const scm_t_string_failed_conversion_handler_SCM_FAILED_CONVERSION_ERROR:
    scm_t_string_failed_conversion_handler = 0;
pub const scm_t_string_failed_conversion_handler_SCM_FAILED_CONVERSION_QUESTION_MARK:
    scm_t_string_failed_conversion_handler = 1;
pub const scm_t_string_failed_conversion_handler_SCM_FAILED_CONVERSION_ESCAPE_SEQUENCE:
    scm_t_string_failed_conversion_handler = 2;
pub type scm_t_string_failed_conversion_handler = ::std::os::raw::c_uint;
extern "C" {
    pub static mut scm_nullstr: SCM;
}
extern "C" {
    pub fn scm_string_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string(chrs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_string(k: SCM, chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_length(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_utf8_length(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_bytes_per_char(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ref(str_: SCM, k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_set_x(str_: SCM, k: SCM, chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring(str_: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_read_only(str_: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_shared(str_: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_copy(str_: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_append(args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_from_stringn(
        str_: *const ::std::os::raw::c_char,
        len: size_t,
        encoding: *const ::std::os::raw::c_char,
        handler: scm_t_string_failed_conversion_handler,
    ) -> SCM;
}
extern "C" {
    pub fn scm_c_make_string(len: size_t, chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_string_length(str_: SCM) -> size_t;
}
extern "C" {
    pub fn scm_c_string_utf8_length(str_: SCM) -> size_t;
}
extern "C" {
    pub fn scm_c_symbol_length(sym: SCM) -> size_t;
}
extern "C" {
    pub fn scm_c_string_ref(str_: SCM, pos: size_t) -> SCM;
}
extern "C" {
    pub fn scm_c_string_set_x(str_: SCM, pos: size_t, chr: SCM);
}
extern "C" {
    pub fn scm_c_substring(str_: SCM, start: size_t, end: size_t) -> SCM;
}
extern "C" {
    pub fn scm_c_substring_read_only(str_: SCM, start: size_t, end: size_t) -> SCM;
}
extern "C" {
    pub fn scm_c_substring_shared(str_: SCM, start: size_t, end: size_t) -> SCM;
}
extern "C" {
    pub fn scm_c_substring_copy(str_: SCM, start: size_t, end: size_t) -> SCM;
}
extern "C" {
    pub fn scm_from_locale_string(str_: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_from_locale_stringn(str_: *const ::std::os::raw::c_char, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_take_locale_string(str_: *mut ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_take_locale_stringn(str_: *mut ::std::os::raw::c_char, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_to_locale_string(str_: SCM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_to_locale_stringn(str_: SCM, lenp: *mut size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_from_latin1_string(str_: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_from_latin1_stringn(str_: *const ::std::os::raw::c_char, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_to_latin1_string(str_: SCM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_to_latin1_stringn(str_: SCM, lenp: *mut size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_to_utf8_string(str_: SCM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_to_utf8_stringn(str_: SCM, lenp: *mut size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_from_utf8_string(str_: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_from_utf8_stringn(str_: *const ::std::os::raw::c_char, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_to_utf32_string(str_: SCM) -> *mut scm_t_wchar;
}
extern "C" {
    pub fn scm_to_utf32_stringn(str_: SCM, lenp: *mut size_t) -> *mut scm_t_wchar;
}
extern "C" {
    pub fn scm_from_utf32_string(str_: *const scm_t_wchar) -> SCM;
}
extern "C" {
    pub fn scm_from_utf32_stringn(str_: *const scm_t_wchar, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_to_stringn(
        str_: SCM,
        lenp: *mut size_t,
        encoding: *const ::std::os::raw::c_char,
        handler: scm_t_string_failed_conversion_handler,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_to_locale_stringbuf(
        str_: SCM,
        buf: *mut ::std::os::raw::c_char,
        max_len: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn scm_string_normalize_nfd(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_normalize_nfkd(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_normalize_nfc(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_normalize_nfkc(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_makfromstrs(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> SCM;
}
extern "C" {
    pub fn scm_i_make_string(
        len: size_t,
        datap: *mut *mut ::std::os::raw::c_char,
        read_only_p: ::std::os::raw::c_int,
    ) -> SCM;
}
extern "C" {
    pub fn scm_i_make_wide_string(
        len: size_t,
        datap: *mut *mut scm_t_wchar,
        read_only_p: ::std::os::raw::c_int,
    ) -> SCM;
}
extern "C" {
    pub fn scm_i_set_string_read_only_x(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_substring(str_: SCM, start: size_t, end: size_t) -> SCM;
}
extern "C" {
    pub fn scm_i_substring_read_only(str_: SCM, start: size_t, end: size_t) -> SCM;
}
extern "C" {
    pub fn scm_i_substring_shared(str_: SCM, start: size_t, end: size_t) -> SCM;
}
extern "C" {
    pub fn scm_i_substring_copy(str_: SCM, start: size_t, end: size_t) -> SCM;
}
extern "C" {
    pub fn scm_i_string_length(str_: SCM) -> size_t;
}
extern "C" {
    pub fn scm_i_string_chars(str_: SCM) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_string_writable_chars(str_: SCM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_string_wide_chars(str_: SCM) -> *const scm_t_wchar;
}
extern "C" {
    pub fn scm_i_string_data(str_: SCM) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_i_string_start_writing(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_string_stop_writing();
}
extern "C" {
    pub fn scm_i_is_narrow_string(str_: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_string_ref(str_: SCM, x: size_t) -> scm_t_wchar;
}
extern "C" {
    pub fn scm_i_string_contains_char(
        str_: SCM,
        c: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_string_strcmp(
        sstr: SCM,
        start_x: size_t,
        cstr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_string_set_x(str_: SCM, p: size_t, chr: scm_t_wchar);
}
extern "C" {
    pub fn scm_i_make_symbol(
        name: SCM,
        flags: scm_t_bits,
        hash: ::std::os::raw::c_ulong,
        props: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_i_c_make_symbol(
        name: *const ::std::os::raw::c_char,
        len: size_t,
        flags: scm_t_bits,
        hash: ::std::os::raw::c_ulong,
        props: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_i_symbol_chars(sym: SCM) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_symbol_wide_chars(sym: SCM) -> *const scm_t_wchar;
}
extern "C" {
    pub fn scm_i_symbol_length(sym: SCM) -> size_t;
}
extern "C" {
    pub fn scm_i_is_narrow_symbol(str_: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_try_narrow_string(str_: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_symbol_substring(sym: SCM, start: size_t, end: size_t) -> SCM;
}
extern "C" {
    pub fn scm_i_symbol_ref(sym: SCM, x: size_t) -> scm_t_wchar;
}
extern "C" {
    pub fn scm_encoding_error(
        subr: *const ::std::os::raw::c_char,
        err: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
        port: SCM,
        chr: SCM,
    );
}
extern "C" {
    pub fn scm_decoding_error(
        subr: *const ::std::os::raw::c_char,
        err: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
        port: SCM,
    );
}
extern "C" {
    pub fn scm_i_allocate_string_pointers(list: SCM) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_get_substring_spec(
        len: size_t,
        start: SCM,
        cstart: *mut size_t,
        end: SCM,
        cend: *mut size_t,
    );
}
extern "C" {
    pub fn scm_sys_string_dump(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_symbol_dump(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_deprecated_stringp(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_deprecated_string_chars(str_: SCM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_deprecated_string_length(str_: SCM) -> size_t;
}
extern "C" {
    pub fn scm_init_strings();
}
pub const scm_t_port_rw_active_SCM_PORT_NEITHER: scm_t_port_rw_active = 0;
pub const scm_t_port_rw_active_SCM_PORT_READ: scm_t_port_rw_active = 1;
pub const scm_t_port_rw_active_SCM_PORT_WRITE: scm_t_port_rw_active = 2;
pub type scm_t_port_rw_active = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_port {
    pub port: SCM,
    pub revealed: ::std::os::raw::c_int,
    pub stream: scm_t_bits,
    pub file_name: SCM,
    pub line_number: ::std::os::raw::c_long,
    pub column_number: ::std::os::raw::c_int,
    pub encoding: *mut ::std::os::raw::c_char,
    pub ilseq_handler: scm_t_string_failed_conversion_handler,
    pub read_buf: *mut ::std::os::raw::c_uchar,
    pub read_pos: *const ::std::os::raw::c_uchar,
    pub read_end: *mut ::std::os::raw::c_uchar,
    pub read_buf_size: scm_t_off,
    pub saved_read_buf: *mut ::std::os::raw::c_uchar,
    pub saved_read_pos: *const ::std::os::raw::c_uchar,
    pub saved_read_end: *mut ::std::os::raw::c_uchar,
    pub saved_read_buf_size: scm_t_off,
    pub write_buf: *mut ::std::os::raw::c_uchar,
    pub write_pos: *mut ::std::os::raw::c_uchar,
    pub write_end: *mut ::std::os::raw::c_uchar,
    pub write_buf_size: scm_t_off,
    pub shortbuf: ::std::os::raw::c_uchar,
    pub rw_random: ::std::os::raw::c_int,
    pub rw_active: scm_t_port_rw_active,
    pub putback_buf: *mut ::std::os::raw::c_uchar,
    pub putback_buf_size: size_t,
    pub input_cd: *mut ::std::os::raw::c_void,
    pub output_cd: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_scm_t_port() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_port>(),
        208usize,
        concat!("Size of: ", stringify!(scm_t_port))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_port>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_port))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).revealed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(revealed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).stream as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).file_name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(file_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).line_number as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(line_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).column_number as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(column_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).encoding as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).ilseq_handler as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(ilseq_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).read_buf as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(read_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).read_pos as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(read_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).read_end as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).read_buf_size as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(read_buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).saved_read_buf as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(saved_read_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).saved_read_pos as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(saved_read_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).saved_read_end as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(saved_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).saved_read_buf_size as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(saved_read_buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).write_buf as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(write_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).write_pos as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(write_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).write_end as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).write_buf_size as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(write_buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).shortbuf as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).rw_random as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(rw_random)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).rw_active as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(rw_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).putback_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(putback_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).putback_buf_size as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(putback_buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).input_cd as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(input_cd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_port>())).output_cd as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_port),
            "::",
            stringify!(output_cd)
        )
    );
}
extern "C" {
    pub static mut scm_i_port_table_mutex: pthread_mutex_t;
}
extern "C" {
    pub static mut scm_i_port_weak_hash: SCM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_ptob_descriptor {
    pub name: *mut ::std::os::raw::c_char,
    pub mark: ::std::option::Option<unsafe extern "C" fn(arg1: SCM) -> SCM>,
    pub free: ::std::option::Option<unsafe extern "C" fn(arg1: SCM) -> size_t>,
    pub print: ::std::option::Option<
        unsafe extern "C" fn(
            exp: SCM,
            port: SCM,
            pstate: *mut scm_print_state,
        ) -> ::std::os::raw::c_int,
    >,
    pub equalp: ::std::option::Option<unsafe extern "C" fn(arg1: SCM, arg2: SCM) -> SCM>,
    pub close: ::std::option::Option<unsafe extern "C" fn(port: SCM) -> ::std::os::raw::c_int>,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(port: SCM, data: *const ::std::os::raw::c_void, size: size_t),
    >,
    pub flush: ::std::option::Option<unsafe extern "C" fn(port: SCM)>,
    pub end_input:
        ::std::option::Option<unsafe extern "C" fn(port: SCM, offset: ::std::os::raw::c_int)>,
    pub fill_input: ::std::option::Option<unsafe extern "C" fn(port: SCM) -> ::std::os::raw::c_int>,
    pub input_waiting:
        ::std::option::Option<unsafe extern "C" fn(port: SCM) -> ::std::os::raw::c_int>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            port: SCM,
            OFFSET: scm_t_off,
            WHENCE: ::std::os::raw::c_int,
        ) -> scm_t_off,
    >,
    pub truncate: ::std::option::Option<unsafe extern "C" fn(port: SCM, length: scm_t_off)>,
}
#[test]
fn bindgen_test_layout_scm_t_ptob_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_ptob_descriptor>(),
        104usize,
        concat!("Size of: ", stringify!(scm_t_ptob_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_ptob_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_ptob_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_ptob_descriptor>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_ptob_descriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_ptob_descriptor>())).mark as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_ptob_descriptor),
            "::",
            stringify!(mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_ptob_descriptor>())).free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_ptob_descriptor),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_ptob_descriptor>())).print as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_ptob_descriptor),
            "::",
            stringify!(print)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_ptob_descriptor>())).equalp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_ptob_descriptor),
            "::",
            stringify!(equalp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_ptob_descriptor>())).close as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_ptob_descriptor),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_ptob_descriptor>())).write as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_ptob_descriptor),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_ptob_descriptor>())).flush as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_ptob_descriptor),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_ptob_descriptor>())).end_input as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_ptob_descriptor),
            "::",
            stringify!(end_input)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<scm_t_ptob_descriptor>())).fill_input as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_ptob_descriptor),
            "::",
            stringify!(fill_input)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<scm_t_ptob_descriptor>())).input_waiting as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_ptob_descriptor),
            "::",
            stringify!(input_waiting)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_ptob_descriptor>())).seek as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_ptob_descriptor),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_ptob_descriptor>())).truncate as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_ptob_descriptor),
            "::",
            stringify!(truncate)
        )
    );
}
extern "C" {
    pub static mut scm_ptobs: *mut scm_t_ptob_descriptor;
}
extern "C" {
    pub static mut scm_numptob: ::std::os::raw::c_long;
}
extern "C" {
    pub fn scm_markstream(ptr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_port_type(
        name: *mut ::std::os::raw::c_char,
        fill_input: ::std::option::Option<unsafe extern "C" fn(port: SCM) -> ::std::os::raw::c_int>,
        write: ::std::option::Option<
            unsafe extern "C" fn(port: SCM, data: *const ::std::os::raw::c_void, size: size_t),
        >,
    ) -> scm_t_bits;
}
extern "C" {
    pub fn scm_set_port_mark(
        tc: scm_t_bits,
        mark: ::std::option::Option<unsafe extern "C" fn(arg1: SCM) -> SCM>,
    );
}
extern "C" {
    pub fn scm_set_port_free(
        tc: scm_t_bits,
        free: ::std::option::Option<unsafe extern "C" fn(arg1: SCM) -> size_t>,
    );
}
extern "C" {
    pub fn scm_set_port_print(
        tc: scm_t_bits,
        print: ::std::option::Option<
            unsafe extern "C" fn(
                exp: SCM,
                port: SCM,
                pstate: *mut scm_print_state,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn scm_set_port_equalp(
        tc: scm_t_bits,
        equalp: ::std::option::Option<unsafe extern "C" fn(arg1: SCM, arg2: SCM) -> SCM>,
    );
}
extern "C" {
    pub fn scm_set_port_close(
        tc: scm_t_bits,
        close: ::std::option::Option<unsafe extern "C" fn(arg1: SCM) -> ::std::os::raw::c_int>,
    );
}
extern "C" {
    pub fn scm_set_port_flush(
        tc: scm_t_bits,
        flush: ::std::option::Option<unsafe extern "C" fn(port: SCM)>,
    );
}
extern "C" {
    pub fn scm_set_port_end_input(
        tc: scm_t_bits,
        end_input: ::std::option::Option<
            unsafe extern "C" fn(port: SCM, offset: ::std::os::raw::c_int),
        >,
    );
}
extern "C" {
    pub fn scm_set_port_seek(
        tc: scm_t_bits,
        seek: ::std::option::Option<
            unsafe extern "C" fn(
                port: SCM,
                OFFSET: scm_t_off,
                WHENCE: ::std::os::raw::c_int,
            ) -> scm_t_off,
        >,
    );
}
extern "C" {
    pub fn scm_set_port_truncate(
        tc: scm_t_bits,
        truncate: ::std::option::Option<unsafe extern "C" fn(port: SCM, length: scm_t_off)>,
    );
}
extern "C" {
    pub fn scm_set_port_input_waiting(
        tc: scm_t_bits,
        input_waiting: ::std::option::Option<
            unsafe extern "C" fn(arg1: SCM) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn scm_char_ready_p(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_from_input_buffers(
        port: SCM,
        dest: *mut ::std::os::raw::c_char,
        read_len: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn scm_drain_input(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_current_input_port() -> SCM;
}
extern "C" {
    pub fn scm_current_output_port() -> SCM;
}
extern "C" {
    pub fn scm_current_error_port() -> SCM;
}
extern "C" {
    pub fn scm_current_warning_port() -> SCM;
}
extern "C" {
    pub fn scm_current_load_port() -> SCM;
}
extern "C" {
    pub fn scm_set_current_input_port(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_current_output_port(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_current_error_port(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_current_warning_port(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynwind_current_input_port(port: SCM);
}
extern "C" {
    pub fn scm_dynwind_current_output_port(port: SCM);
}
extern "C" {
    pub fn scm_dynwind_current_error_port(port: SCM);
}
extern "C" {
    pub fn scm_new_port_table_entry(tag: scm_t_bits) -> SCM;
}
extern "C" {
    pub fn scm_grow_port_cbuf(port: SCM, requested: size_t);
}
extern "C" {
    pub fn scm_pt_size() -> SCM;
}
extern "C" {
    pub fn scm_pt_member(member: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_non_buffer(pt: *mut scm_t_port);
}
extern "C" {
    pub fn scm_revealed_count(port: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_port_revealed(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_port_revealed_x(port: SCM, rcount: SCM) -> SCM;
}
extern "C" {
    pub fn scm_mode_bits(modes: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scm_port_mode(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_close_input_port(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_close_output_port(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_close_port(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_for_each(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_port_for_each(
        proc_: ::std::option::Option<
            unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, p: SCM),
        >,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn scm_input_port_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_output_port_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_closed_p(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_eof_object_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_force_output(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_flush_all_ports() -> SCM;
}
extern "C" {
    pub fn scm_read_char(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getc(port: SCM) -> scm_t_wchar;
}
extern "C" {
    pub fn scm_c_read(port: SCM, buffer: *mut ::std::os::raw::c_void, size: size_t) -> size_t;
}
extern "C" {
    pub fn scm_c_write(port: SCM, buffer: *const ::std::os::raw::c_void, size: size_t);
}
extern "C" {
    pub fn scm_lfwrite(ptr: *const ::std::os::raw::c_char, size: size_t, port: SCM);
}
extern "C" {
    pub fn scm_lfwrite_substr(str_: SCM, start: size_t, end: size_t, port: SCM);
}
extern "C" {
    pub fn scm_flush(port: SCM);
}
extern "C" {
    pub fn scm_end_input(port: SCM);
}
extern "C" {
    pub fn scm_fill_input(port: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_unget_bytes(buf: *const ::std::os::raw::c_uchar, len: size_t, port: SCM);
}
extern "C" {
    pub fn scm_unget_byte(c: ::std::os::raw::c_int, port: SCM);
}
extern "C" {
    pub fn scm_ungetc(c: scm_t_wchar, port: SCM);
}
extern "C" {
    pub fn scm_ungets(s: *const ::std::os::raw::c_char, n: ::std::os::raw::c_int, port: SCM);
}
extern "C" {
    pub fn scm_peek_char(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_unread_char(cobj: SCM, port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_unread_string(str_: SCM, port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_seek(object: SCM, offset: SCM, whence: SCM) -> SCM;
}
extern "C" {
    pub fn scm_truncate_file(object: SCM, length: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_line(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_port_line_x(port: SCM, line: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_column(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_port_column_x(port: SCM, line: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_filename(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_port_filename_x(port: SCM, filename: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_port_property(port: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_set_port_property_x(port: SCM, key: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_default_port_encoding() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_set_default_port_encoding(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_i_set_port_encoding_x(port: SCM, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_port_encoding(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_port_encoding_x(port: SCM, encoding: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_default_port_conversion_handler() -> scm_t_string_failed_conversion_handler;
}
extern "C" {
    pub fn scm_i_set_default_port_conversion_handler(arg1: scm_t_string_failed_conversion_handler);
}
extern "C" {
    pub fn scm_slow_get_byte_or_eof(port: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_slow_peek_byte_or_eof(port: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_port_conversion_strategy(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_port_conversion_strategy_x(port: SCM, behavior: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_print(exp: SCM, port: SCM, arg1: *mut scm_print_state)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_print_port_mode(exp: SCM, port: SCM);
}
extern "C" {
    pub fn scm_void_port(mode_str: *mut ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_sys_make_void_port(mode: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_ports();
}
extern "C" {
    pub fn scm_add_to_port_table(port: SCM) -> *mut scm_t_port;
}
extern "C" {
    pub fn scm_i_mode_bits(modes: SCM) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scm_i_dynwind_current_load_port(port: SCM);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_fport {
    pub fdes: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_scm_t_fport() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_fport>(),
        4usize,
        concat!("Size of: ", stringify!(scm_t_fport))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_fport>(),
        4usize,
        concat!("Alignment of ", stringify!(scm_t_fport))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_fport>())).fdes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_fport),
            "::",
            stringify!(fdes)
        )
    );
}
extern "C" {
    pub static mut scm_tc16_fport: scm_t_bits;
}
extern "C" {
    pub fn scm_setbuf0(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setvbuf(port: SCM, mode: SCM, size: SCM) -> SCM;
}
extern "C" {
    pub fn scm_evict_ports(fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn scm_i_mode_to_open_flags(
        mode: SCM,
        is_binary: *mut ::std::os::raw::c_int,
        FUNC_NAME: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_open_file_with_encoding(
        filename: SCM,
        modes: SCM,
        guess_encoding: SCM,
        encoding: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_open_file(filename: SCM, modes: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fdes_to_port(
        fdes: ::std::os::raw::c_int,
        mode: *mut ::std::os::raw::c_char,
        name: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_file_port_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_fports_keywords();
}
extern "C" {
    pub fn scm_init_fports();
}
extern "C" {
    pub fn scm_i_fdes_to_port(
        fdes: ::std::os::raw::c_int,
        mode_bits: ::std::os::raw::c_long,
        name: SCM,
    ) -> SCM;
}
pub const scm_t_c_hook_type_SCM_C_HOOK_NORMAL: scm_t_c_hook_type = 0;
pub const scm_t_c_hook_type_SCM_C_HOOK_OR: scm_t_c_hook_type = 1;
pub const scm_t_c_hook_type_SCM_C_HOOK_AND: scm_t_c_hook_type = 2;
pub type scm_t_c_hook_type = ::std::os::raw::c_uint;
pub type scm_t_c_hook_function = ::std::option::Option<
    unsafe extern "C" fn(
        hook_data: *mut ::std::os::raw::c_void,
        fn_data: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_c_hook_entry {
    pub next: *mut scm_t_c_hook_entry,
    pub func: scm_t_c_hook_function,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_scm_t_c_hook_entry() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_c_hook_entry>(),
        24usize,
        concat!("Size of: ", stringify!(scm_t_c_hook_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_c_hook_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_c_hook_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_c_hook_entry>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_c_hook_entry),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_c_hook_entry>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_c_hook_entry),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_c_hook_entry>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_c_hook_entry),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_c_hook {
    pub first: *mut scm_t_c_hook_entry,
    pub type_: scm_t_c_hook_type,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_scm_t_c_hook() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_c_hook>(),
        24usize,
        concat!("Size of: ", stringify!(scm_t_c_hook))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_c_hook>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_c_hook))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_c_hook>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_c_hook),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_c_hook>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_c_hook),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_c_hook>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_c_hook),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn scm_c_hook_init(
        hook: *mut scm_t_c_hook,
        hook_data: *mut ::std::os::raw::c_void,
        type_: scm_t_c_hook_type,
    );
}
extern "C" {
    pub fn scm_c_hook_add(
        hook: *mut scm_t_c_hook,
        func: scm_t_c_hook_function,
        fn_data: *mut ::std::os::raw::c_void,
        appendp: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn scm_c_hook_remove(
        hook: *mut scm_t_c_hook,
        func: scm_t_c_hook_function,
        fn_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn scm_c_hook_run(
        hook: *mut scm_t_c_hook,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub static mut scm_tc16_hook: scm_t_bits;
}
extern "C" {
    pub fn scm_make_hook(n_args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hook_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hook_empty_p(hook: SCM) -> SCM;
}
extern "C" {
    pub fn scm_add_hook_x(hook: SCM, thunk: SCM, appendp: SCM) -> SCM;
}
extern "C" {
    pub fn scm_remove_hook_x(hook: SCM, thunk: SCM) -> SCM;
}
extern "C" {
    pub fn scm_reset_hook_x(hook: SCM) -> SCM;
}
extern "C" {
    pub fn scm_run_hook(hook: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_run_hook(hook: SCM, args: SCM);
}
extern "C" {
    pub fn scm_c_run_hookn(hook: SCM, argv: *mut SCM, nargs: size_t);
}
extern "C" {
    pub fn scm_hook_to_list(hook: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_hooks();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_cell {
    pub word_0: SCM,
    pub word_1: SCM,
}
#[test]
fn bindgen_test_layout_scm_t_cell() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_cell>(),
        16usize,
        concat!("Size of: ", stringify!(scm_t_cell))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_cell>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_cell))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_cell>())).word_0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_cell),
            "::",
            stringify!(word_0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_cell>())).word_1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_cell),
            "::",
            stringify!(word_1)
        )
    );
}
extern "C" {
    pub static mut scm_i_gc_admin_mutex: pthread_mutex_t;
}
extern "C" {
    pub static mut scm_i_sweep_mutex: pthread_mutex_t;
}
extern "C" {
    pub static mut scm_default_init_heap_size_1: size_t;
}
extern "C" {
    pub static mut scm_default_min_yield_1: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut scm_default_init_heap_size_2: size_t;
}
extern "C" {
    pub static mut scm_default_min_yield_2: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut scm_default_max_segment_size: size_t;
}
extern "C" {
    pub static mut scm_gc_ports_collected: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut scm_after_gc_hook: SCM;
}
extern "C" {
    pub static mut scm_before_gc_c_hook: scm_t_c_hook;
}
extern "C" {
    pub static mut scm_before_mark_c_hook: scm_t_c_hook;
}
extern "C" {
    pub static mut scm_before_sweep_c_hook: scm_t_c_hook;
}
extern "C" {
    pub static mut scm_after_sweep_c_hook: scm_t_c_hook;
}
extern "C" {
    pub static mut scm_after_gc_c_hook: scm_t_c_hook;
}
extern "C" {
    pub fn scm_set_debug_cell_accesses_x(flag: SCM) -> SCM;
}
extern "C" {
    pub fn scm_object_address(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gc_enable() -> SCM;
}
extern "C" {
    pub fn scm_gc_disable() -> SCM;
}
extern "C" {
    pub fn scm_gc_dump() -> SCM;
}
extern "C" {
    pub fn scm_gc_stats() -> SCM;
}
extern "C" {
    pub fn scm_gc() -> SCM;
}
extern "C" {
    pub fn scm_i_gc(what: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_gc_mark(p: SCM);
}
extern "C" {
    pub fn scm_gc_sweep();
}
extern "C" {
    pub fn scm_gc_register_allocation(size: size_t);
}
extern "C" {
    pub fn scm_malloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_calloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_realloc(
        mem: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_strdup(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_strndup(
        str_: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_gc_register_collectable_memory(
        mem: *mut ::std::os::raw::c_void,
        size: size_t,
        what: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn scm_gc_unregister_collectable_memory(
        mem: *mut ::std::os::raw::c_void,
        size: size_t,
        what: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn scm_gc_malloc_pointerless(
        size: size_t,
        what: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_gc_calloc(
        size: size_t,
        what: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_gc_malloc(
        size: size_t,
        what: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_gc_realloc(
        mem: *mut ::std::os::raw::c_void,
        old_size: size_t,
        new_size: size_t,
        what: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_gc_free(
        mem: *mut ::std::os::raw::c_void,
        size: size_t,
        what: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn scm_gc_strdup(
        str_: *const ::std::os::raw::c_char,
        what: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_gc_strndup(
        str_: *const ::std::os::raw::c_char,
        n: size_t,
        what: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_remember_upto_here_1(obj: SCM);
}
extern "C" {
    pub fn scm_remember_upto_here_2(obj1: SCM, obj2: SCM);
}
extern "C" {
    pub fn scm_remember_upto_here(obj1: SCM, ...);
}
extern "C" {
    pub fn scm_return_first(elt: SCM, ...) -> SCM;
}
extern "C" {
    pub fn scm_return_first_int(x: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_permanent_object(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gc_protect_object(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gc_unprotect_object(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gc_register_root(p: *mut SCM);
}
extern "C" {
    pub fn scm_gc_unregister_root(p: *mut SCM);
}
extern "C" {
    pub fn scm_gc_register_roots(b: *mut SCM, n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn scm_gc_unregister_roots(b: *mut SCM, n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub static mut scm_protects: SCM;
}
extern "C" {
    pub fn scm_storage_prehistory();
}
extern "C" {
    pub fn scm_init_gc_protect_object();
}
extern "C" {
    pub fn scm_init_gc();
}
extern "C" {
    pub fn scm_deprecated_newcell() -> SCM;
}
extern "C" {
    pub fn scm_deprecated_newcell2() -> SCM;
}
extern "C" {
    pub fn scm_must_malloc(
        len: size_t,
        what: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_must_realloc(
        where_: *mut ::std::os::raw::c_void,
        olen: size_t,
        len: size_t,
        what: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_must_strdup(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_must_strndup(
        str_: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_done_malloc(size: ::std::os::raw::c_long);
}
extern "C" {
    pub fn scm_done_free(size: ::std::os::raw::c_long);
}
extern "C" {
    pub fn scm_must_free(obj: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub static mut scm_print_carefully_p: ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_init_gdbint();
}
extern "C" {
    #[doc = " Arrays"]
    pub fn scm_is_array(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_array_p(v: SCM, unused: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_p_2(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_typed_array(obj: SCM, type_: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_typed_array_p(v: SCM, type_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_array_rank(ra: SCM) -> size_t;
}
extern "C" {
    pub fn scm_array_rank(ra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_array_length(ra: SCM) -> size_t;
}
extern "C" {
    pub fn scm_array_length(ra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_dimensions(ra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_type(ra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_in_bounds_p(v: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_array_ref_1(v: SCM, idx0: ssize_t) -> SCM;
}
extern "C" {
    pub fn scm_c_array_ref_2(v: SCM, idx0: ssize_t, idx1: ssize_t) -> SCM;
}
extern "C" {
    pub fn scm_c_array_set_1_x(v: SCM, obj: SCM, idx0: ssize_t);
}
extern "C" {
    pub fn scm_c_array_set_2_x(v: SCM, obj: SCM, idx0: ssize_t, idx1: ssize_t);
}
extern "C" {
    pub fn scm_array_ref(v: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_set_x(v: SCM, obj: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_to_list(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_generalized_arrays();
}
extern "C" {
    pub fn scm_is_generalized_vector(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_generalized_vector_length(v: SCM) -> size_t;
}
extern "C" {
    pub fn scm_c_generalized_vector_ref(v: SCM, idx: size_t) -> SCM;
}
extern "C" {
    pub fn scm_c_generalized_vector_set_x(v: SCM, idx: size_t, val: SCM);
}
extern "C" {
    pub fn scm_generalized_vector_get_handle(vec: SCM, h: *mut scm_t_array_handle);
}
extern "C" {
    pub fn scm_make_generalized_vector(type_: SCM, len: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_register_vector_constructor(
        type_: SCM,
        ctor: ::std::option::Option<unsafe extern "C" fn(arg1: SCM, arg2: SCM) -> SCM>,
    );
}
extern "C" {
    pub fn scm_init_generalized_vectors();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_method {
    pub generic_function: SCM,
    pub specializers: SCM,
    pub procedure: SCM,
}
#[test]
fn bindgen_test_layout_scm_t_method() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_method>(),
        24usize,
        concat!("Size of: ", stringify!(scm_t_method))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_method>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_method))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_method>())).generic_function as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_method),
            "::",
            stringify!(generic_function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_method>())).specializers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_method),
            "::",
            stringify!(specializers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_method>())).procedure as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_method),
            "::",
            stringify!(procedure)
        )
    );
}
extern "C" {
    pub static mut scm_class_boolean: SCM;
}
extern "C" {
    pub static mut scm_class_char: SCM;
}
extern "C" {
    pub static mut scm_class_pair: SCM;
}
extern "C" {
    pub static mut scm_class_procedure: SCM;
}
extern "C" {
    pub static mut scm_class_string: SCM;
}
extern "C" {
    pub static mut scm_class_symbol: SCM;
}
extern "C" {
    pub static mut scm_class_primitive_generic: SCM;
}
extern "C" {
    pub static mut scm_class_vector: SCM;
}
extern "C" {
    pub static mut scm_class_null: SCM;
}
extern "C" {
    pub static mut scm_class_real: SCM;
}
extern "C" {
    pub static mut scm_class_complex: SCM;
}
extern "C" {
    pub static mut scm_class_integer: SCM;
}
extern "C" {
    pub static mut scm_class_fraction: SCM;
}
extern "C" {
    pub static mut scm_class_unknown: SCM;
}
extern "C" {
    pub static mut scm_port_class: [SCM; 0usize];
}
extern "C" {
    pub static mut scm_smob_class: [SCM; 0usize];
}
extern "C" {
    pub static mut scm_class_top: SCM;
}
extern "C" {
    pub static mut scm_class_object: SCM;
}
extern "C" {
    pub static mut scm_class_class: SCM;
}
extern "C" {
    pub static mut scm_class_applicable: SCM;
}
extern "C" {
    pub static mut scm_class_applicable_struct: SCM;
}
extern "C" {
    pub static mut scm_class_applicable_struct_with_setter: SCM;
}
extern "C" {
    pub static mut scm_class_generic: SCM;
}
extern "C" {
    pub static mut scm_class_generic_with_setter: SCM;
}
extern "C" {
    pub static mut scm_class_accessor: SCM;
}
extern "C" {
    pub static mut scm_class_extended_generic: SCM;
}
extern "C" {
    pub static mut scm_class_extended_generic_with_setter: SCM;
}
extern "C" {
    pub static mut scm_class_extended_accessor: SCM;
}
extern "C" {
    pub static mut scm_class_method: SCM;
}
extern "C" {
    pub static mut scm_class_accessor_method: SCM;
}
extern "C" {
    pub static mut scm_class_procedure_class: SCM;
}
extern "C" {
    pub static mut scm_class_applicable_struct_class: SCM;
}
extern "C" {
    pub static mut scm_class_number: SCM;
}
extern "C" {
    pub static mut scm_class_list: SCM;
}
extern "C" {
    pub static mut scm_class_keyword: SCM;
}
extern "C" {
    pub static mut scm_class_port: SCM;
}
extern "C" {
    pub static mut scm_class_input_output_port: SCM;
}
extern "C" {
    pub static mut scm_class_input_port: SCM;
}
extern "C" {
    pub static mut scm_class_output_port: SCM;
}
extern "C" {
    pub static mut scm_class_foreign_slot: SCM;
}
extern "C" {
    pub static mut scm_class_self: SCM;
}
extern "C" {
    pub static mut scm_class_protected: SCM;
}
extern "C" {
    pub static mut scm_class_hidden: SCM;
}
extern "C" {
    pub static mut scm_class_opaque: SCM;
}
extern "C" {
    pub static mut scm_class_read_only: SCM;
}
extern "C" {
    pub static mut scm_class_protected_hidden: SCM;
}
extern "C" {
    pub static mut scm_class_protected_opaque: SCM;
}
extern "C" {
    pub static mut scm_class_protected_read_only: SCM;
}
extern "C" {
    pub static mut scm_class_scm: SCM;
}
extern "C" {
    pub static mut scm_class_int: SCM;
}
extern "C" {
    pub static mut scm_class_float: SCM;
}
extern "C" {
    pub static mut scm_class_double: SCM;
}
extern "C" {
    pub static mut scm_s_slot_set_x: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut scm_no_applicable_method: SCM;
}
extern "C" {
    pub static mut scm_module_goops: SCM;
}
extern "C" {
    pub fn scm_goops_version() -> SCM;
}
extern "C" {
    pub fn scm_oldfmt(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_oldfmt0(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_c_oldfmt(
        arg1: *mut ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_load_goops();
}
extern "C" {
    pub fn scm_make_extended_class(
        type_name: *const ::std::os::raw::c_char,
        applicablep: ::std::os::raw::c_int,
    ) -> SCM;
}
extern "C" {
    pub fn scm_make_port_classes(
        ptobnum: ::std::os::raw::c_long,
        type_name: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn scm_ensure_accessor(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_class_of(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_next_method(methods: SCM, args: SCM, gf: SCM) -> SCM;
}
extern "C" {
    pub fn scm_basic_basic_make_class(c: SCM, name: SCM, dsupers: SCM, dslots: SCM) -> SCM;
}
extern "C" {
    pub fn scm_basic_make_class(c: SCM, name: SCM, dsupers: SCM, dslots: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_allocate_instance(c: SCM, initargs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_set_object_setter_x(obj: SCM, setter: SCM) -> SCM;
}
extern "C" {
    pub fn scm_slot_ref(obj: SCM, slot_name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_slot_set_x(obj: SCM, slot_name: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_compute_applicable_methods(
        gf: SCM,
        args: SCM,
        len: ::std::os::raw::c_long,
        scm_find_method: ::std::os::raw::c_int,
    ) -> SCM;
}
extern "C" {
    pub fn scm_sys_compute_applicable_methods(gf: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_compute_slots(c: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_inherit_applicable(c: SCM);
}
extern "C" {
    pub fn scm_i_get_keyword(
        key: SCM,
        l: SCM,
        len: ::std::os::raw::c_long,
        default_value: SCM,
        subr: *const ::std::os::raw::c_char,
    ) -> SCM;
}
extern "C" {
    pub fn scm_get_keyword(key: SCM, l: SCM, default_value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_initialize_object(obj: SCM, initargs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_prep_layout_x(c: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_inherit_magic_x(c: SCM, dsupers: SCM) -> SCM;
}
extern "C" {
    pub fn scm_instance_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_class_name(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_class_direct_supers(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_class_direct_slots(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_class_direct_subclasses(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_class_direct_methods(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_class_precedence_list(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_class_slots(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_generic_function_name(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_generic_function_methods(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_method_generic_function(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_method_specializers(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_method_procedure(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_fast_slot_ref(obj: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_fast_slot_set_x(obj: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_slot_ref_using_class(cls: SCM, obj: SCM, slot_name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_slot_set_using_class_x(cls: SCM, obj: SCM, slot_name: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_slot_bound_using_class_p(cls: SCM, obj: SCM, slot_name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_slot_exists_using_class_p(cls: SCM, obj: SCM, slot_name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_slot_bound_p(obj: SCM, slot_name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_slot_exists_p(obj: SCM, slot_name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_modify_instance(old: SCM, newinst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_modify_class(old: SCM, newcls: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_invalidate_class(cls: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_invalidate_method_cache_x(gf: SCM) -> SCM;
}
extern "C" {
    pub fn scm_generic_capability_p(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_enable_primitive_generic_x(subrs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_primitive_generic_x(subr: SCM, generic: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_generic_generic(subr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_extend_primitive_generic(subr: SCM, extension: SCM);
}
extern "C" {
    pub fn stklos_version() -> SCM;
}
extern "C" {
    pub fn scm_make(args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_find_method(args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_method_more_specific_p(m1: SCM, m2: SCM, targs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_change_object_class(arg1: SCM, arg2: SCM, arg3: SCM);
}
extern "C" {
    pub fn scm_call_generic_3(gf: SCM, a1: SCM, a2: SCM, a3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_define_class_for_vtable(vtable: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_goops_builtins() -> SCM;
}
extern "C" {
    pub fn scm_init_goops();
}
extern "C" {
    pub fn scm_subr_objcode_trampoline(
        nreq: ::std::os::raw::c_uint,
        nopt: ::std::os::raw::c_uint,
        rest: ::std::os::raw::c_uint,
    ) -> SCM;
}
extern "C" {
    pub fn scm_c_make_gsubr(
        name: *const ::std::os::raw::c_char,
        req: ::std::os::raw::c_int,
        opt: ::std::os::raw::c_int,
        rst: ::std::os::raw::c_int,
        fcn: scm_t_subr,
    ) -> SCM;
}
extern "C" {
    pub fn scm_c_make_gsubr_with_generic(
        name: *const ::std::os::raw::c_char,
        req: ::std::os::raw::c_int,
        opt: ::std::os::raw::c_int,
        rst: ::std::os::raw::c_int,
        fcn: scm_t_subr,
        gf: *mut SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_c_define_gsubr(
        name: *const ::std::os::raw::c_char,
        req: ::std::os::raw::c_int,
        opt: ::std::os::raw::c_int,
        rst: ::std::os::raw::c_int,
        fcn: scm_t_subr,
    ) -> SCM;
}
extern "C" {
    pub fn scm_c_define_gsubr_with_generic(
        name: *const ::std::os::raw::c_char,
        req: ::std::os::raw::c_int,
        opt: ::std::os::raw::c_int,
        rst: ::std::os::raw::c_int,
        fcn: scm_t_subr,
        gf: *mut SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_init_gsubr();
}
extern "C" {
    pub fn scm_make_guardian() -> SCM;
}
extern "C" {
    pub fn scm_i_init_guardians_for_gc();
}
extern "C" {
    pub fn scm_i_identify_inaccessible_guardeds();
}
extern "C" {
    pub fn scm_i_mark_inaccessible_guardeds() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_init_guardians();
}
extern "C" {
    pub fn scm_string_hash(
        str_: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_i_locale_string_hash(
        str_: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_i_latin1_string_hash(
        str_: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_i_utf8_string_hash(
        str_: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_i_string_hash(str_: SCM) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_hasher(obj: SCM, n: ::std::os::raw::c_ulong, d: size_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_ihashq(obj: SCM, n: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_hashq(obj: SCM, n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ihashv(obj: SCM, n: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_hashv(obj: SCM, n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ihash(obj: SCM, n: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_hash(obj: SCM, n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_hash();
}
extern "C" {
    pub fn scm_weak_car_pair(car: SCM, cdr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_cdr_pair(car: SCM, cdr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_doubly_weak_pair(car: SCM, cdr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_weak_vector(k: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_vector_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_vector_length(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_vector_ref(v: SCM, k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_vector_set_x(v: SCM, k: SCM, x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_make_weak_vector(k: size_t, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_weak_vector(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_weak_vector_length(vec: SCM) -> size_t;
}
extern "C" {
    pub fn scm_c_weak_vector_ref(v: SCM, k: size_t) -> SCM;
}
extern "C" {
    pub fn scm_c_weak_vector_set_x(v: SCM, k: size_t, x: SCM);
}
extern "C" {
    pub fn scm_make_weak_key_alist_vector(k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_weak_value_alist_vector(k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_doubly_weak_alist_vector(k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_key_alist_vector_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_value_alist_vector_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_doubly_weak_alist_vector_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_weaks_builtins() -> SCM;
}
extern "C" {
    pub fn scm_weaks_prehistory();
}
extern "C" {
    pub fn scm_init_weaks();
}
extern "C" {
    pub fn scm_i_init_weak_vectors_for_gc();
}
extern "C" {
    pub fn scm_i_mark_weak_vector(w: SCM);
}
extern "C" {
    pub fn scm_i_mark_weak_vectors_non_weaks() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_remove_weaks_from_weak_vectors();
}
pub type scm_t_hash_fn = ::std::option::Option<
    unsafe extern "C" fn(
        obj: SCM,
        max: ::std::os::raw::c_ulong,
        closure: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_ulong,
>;
pub type scm_t_assoc_fn = ::std::option::Option<
    unsafe extern "C" fn(obj: SCM, alist: SCM, closure: *mut ::std::os::raw::c_void) -> SCM,
>;
pub type scm_t_hash_predicate_fn = ::std::option::Option<
    unsafe extern "C" fn(obj: SCM, closure: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type scm_t_hash_fold_fn = ::std::option::Option<
    unsafe extern "C" fn(
        closure: *mut ::std::os::raw::c_void,
        key: SCM,
        value: SCM,
        result: SCM,
    ) -> SCM,
>;
pub type scm_t_hash_handle_fn = ::std::option::Option<
    unsafe extern "C" fn(closure: *mut ::std::os::raw::c_void, handle: SCM) -> SCM,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_hashtable {
    pub flags: ::std::os::raw::c_int,
    pub n_items: ::std::os::raw::c_ulong,
    pub lower: ::std::os::raw::c_ulong,
    pub upper: ::std::os::raw::c_ulong,
    pub size_index: ::std::os::raw::c_int,
    pub min_size_index: ::std::os::raw::c_int,
    pub hash_fn: scm_t_hash_fn,
}
#[test]
fn bindgen_test_layout_scm_t_hashtable() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_hashtable>(),
        48usize,
        concat!("Size of: ", stringify!(scm_t_hashtable))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_hashtable>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_hashtable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_hashtable>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_hashtable),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_hashtable>())).n_items as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_hashtable),
            "::",
            stringify!(n_items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_hashtable>())).lower as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_hashtable),
            "::",
            stringify!(lower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_hashtable>())).upper as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_hashtable),
            "::",
            stringify!(upper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_hashtable>())).size_index as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_hashtable),
            "::",
            stringify!(size_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_hashtable>())).min_size_index as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_hashtable),
            "::",
            stringify!(min_size_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_hashtable>())).hash_fn as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_hashtable),
            "::",
            stringify!(hash_fn)
        )
    );
}
extern "C" {
    pub fn scm_vector_to_hash_table(vector: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_make_hash_table(k: ::std::os::raw::c_ulong) -> SCM;
}
extern "C" {
    pub fn scm_make_hash_table(n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_weak_key_hash_table(k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_weak_value_hash_table(k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_doubly_weak_hash_table(k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_table_p(h: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_key_hash_table_p(h: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_value_hash_table_p(h: SCM) -> SCM;
}
extern "C" {
    pub fn scm_doubly_weak_hash_table_p(h: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_rehash(
        table: SCM,
        hash_fn: scm_t_hash_fn,
        closure: *mut ::std::os::raw::c_void,
        func_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn scm_hash_fn_get_handle(
        table: SCM,
        obj: SCM,
        hash_fn: scm_t_hash_fn,
        assoc_fn: scm_t_assoc_fn,
        closure: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_hash_fn_get_handle_by_hash(
        table: SCM,
        raw_hash: ::std::os::raw::c_ulong,
        predicate_fn: scm_t_hash_predicate_fn,
        closure: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_hash_fn_create_handle_x(
        table: SCM,
        obj: SCM,
        init: SCM,
        hash_fn: scm_t_hash_fn,
        assoc_fn: scm_t_assoc_fn,
        closure: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_hash_fn_ref(
        table: SCM,
        obj: SCM,
        dflt: SCM,
        hash_fn: scm_t_hash_fn,
        assoc_fn: scm_t_assoc_fn,
        closure: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_hash_fn_set_x(
        table: SCM,
        obj: SCM,
        val: SCM,
        hash_fn: scm_t_hash_fn,
        assoc_fn: scm_t_assoc_fn,
        closure: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_hash_fn_remove_x(
        table: SCM,
        obj: SCM,
        hash_fn: scm_t_hash_fn,
        assoc_fn: scm_t_assoc_fn,
        closure: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_internal_hash_fold(
        fn_: scm_t_hash_fold_fn,
        closure: *mut ::std::os::raw::c_void,
        init: SCM,
        table: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_internal_hash_for_each_handle(
        fn_: scm_t_hash_handle_fn,
        closure: *mut ::std::os::raw::c_void,
        table: SCM,
    );
}
extern "C" {
    pub fn scm_hash_clear_x(table: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashq_get_handle(table: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashq_create_handle_x(table: SCM, obj: SCM, init: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashq_ref(table: SCM, obj: SCM, dflt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashq_set_x(table: SCM, obj: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashq_remove_x(table: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashv_get_handle(table: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashv_create_handle_x(table: SCM, obj: SCM, init: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashv_ref(table: SCM, obj: SCM, dflt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashv_set_x(table: SCM, obj: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashv_remove_x(table: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_get_handle(table: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_create_handle_x(table: SCM, obj: SCM, init: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_ref(table: SCM, obj: SCM, dflt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_set_x(table: SCM, obj: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_remove_x(table: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashx_get_handle(hash: SCM, assoc: SCM, table: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashx_create_handle_x(hash: SCM, assoc: SCM, table: SCM, obj: SCM, init: SCM)
        -> SCM;
}
extern "C" {
    pub fn scm_hashx_ref(hash: SCM, assoc: SCM, table: SCM, obj: SCM, dflt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashx_set_x(hash: SCM, assoc: SCM, table: SCM, obj: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashx_remove_x(hash: SCM, assoc: SCM, table: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_fold(proc_: SCM, init: SCM, hash: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_for_each(proc_: SCM, hash: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_for_each_handle(proc_: SCM, hash: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_map_to_list(proc_: SCM, hash: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_count(hash: SCM, pred: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_hashtable_print(exp: SCM, port: SCM, pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_init_hashtab();
}
extern "C" {
    pub static mut scm_global_locale: SCM;
}
extern "C" {
    pub fn scm_make_locale(category_mask: SCM, locale_name: SCM, base_locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_locale_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_locale_lt(s1: SCM, s2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_locale_gt(s1: SCM, s2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_locale_ci_lt(s1: SCM, s2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_locale_ci_gt(s1: SCM, s2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_locale_ci_eq(s1: SCM, s2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_locale_lt(c1: SCM, c2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_locale_gt(c1: SCM, c2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_locale_ci_lt(c1: SCM, c2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_locale_ci_gt(c1: SCM, c2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_locale_ci_eq(c1: SCM, c2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_locale_upcase(chr: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_locale_downcase(chr: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_locale_titlecase(chr: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_locale_upcase(chr: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_locale_downcase(chr: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_locale_titlecase(chr: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_locale_string_to_integer(str_: SCM, base: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_locale_string_to_inexact(str_: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_nl_langinfo(item: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_i18n();
}
extern "C" {
    pub fn scm_bootstrap_i18n();
}
extern "C" {
    pub static mut scm_i_init_mutex: pthread_mutex_t;
}
extern "C" {
    pub static mut scm_initialized_p: ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_init_guile();
}
extern "C" {
    pub fn scm_boot_guile(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        main_func: ::std::option::Option<
            unsafe extern "C" fn(
                closure: *mut ::std::os::raw::c_void,
                argc: ::std::os::raw::c_int,
                argv: *mut *mut ::std::os::raw::c_char,
            ),
        >,
        closure: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn scm_i_init_guile(base: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_load_startup_files();
}
extern "C" {
    pub fn scm_ftell(object: SCM) -> SCM;
}
extern "C" {
    pub fn scm_redirect_port(into_pt: SCM, from_pt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dup_to_fdes(fd_or_port: SCM, newfd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dup2(oldfd: SCM, newfd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fileno(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_isatty_p(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fdopen(fdes: SCM, modes: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_move_to_fdes(port: SCM, fd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fdes_to_ports(fd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_ioext();
}
extern "C" {
    pub fn scm_read_delimited_x(
        delims: SCM,
        buf: SCM,
        gobble: SCM,
        port: SCM,
        offset: SCM,
        length: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_read_line(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_write_line(obj: SCM, port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_rdelim_builtins() -> SCM;
}
extern "C" {
    pub fn scm_init_rdelim();
}
extern "C" {
    pub fn scm_read_string_x_partial(str_: SCM, port_or_fdes: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_write_string_partial(str_: SCM, port_or_fdes: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_rw_builtins() -> SCM;
}
extern "C" {
    pub fn scm_init_rw();
}
extern "C" {
    pub static mut scm_tc16_keyword: scm_t_bits;
}
extern "C" {
    pub fn scm_keyword_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_to_keyword(symbol: SCM) -> SCM;
}
extern "C" {
    pub fn scm_keyword_to_symbol(keyword: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_keyword(val: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_from_locale_keyword(name: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_from_locale_keywordn(name: *const ::std::os::raw::c_char, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_from_latin1_keyword(name: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_from_utf8_keyword(name: *const ::std::os::raw::c_char) -> SCM;
}
pub const scm_keyword_arguments_flags_SCM_ALLOW_OTHER_KEYS: scm_keyword_arguments_flags = 1;
pub const scm_keyword_arguments_flags_SCM_ALLOW_NON_KEYWORD_ARGUMENTS: scm_keyword_arguments_flags =
    2;
pub type scm_keyword_arguments_flags = ::std::os::raw::c_uint;
pub use self::scm_keyword_arguments_flags as scm_t_keyword_arguments_flags;
extern "C" {
    pub fn scm_c_bind_keyword_arguments(
        subr: *const ::std::os::raw::c_char,
        rest: SCM,
        flags: scm_t_keyword_arguments_flags,
        ...
    );
}
extern "C" {
    pub fn scm_init_keywords();
}
extern "C" {
    pub fn scm_list_1(e1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_2(e1: SCM, e2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_3(e1: SCM, e2: SCM, e3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_4(e1: SCM, e2: SCM, e3: SCM, e4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_5(e1: SCM, e2: SCM, e3: SCM, e4: SCM, e5: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_n(elt: SCM, ...) -> SCM;
}
extern "C" {
    pub fn scm_list(objs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_head(lst: SCM, k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_list(n: SCM, init: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cons_star(arg: SCM, objs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_null_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ilength(sx: SCM) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scm_length(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_append(args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_append_x(args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_reverse(lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_reverse_x(lst: SCM, newtail: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_ref(lst: SCM, k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_set_x(lst: SCM, k: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_cdr_set_x(lst: SCM, k: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_last_pair(sx: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_tail(lst: SCM, k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_memq(x: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_memq(x: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_memv(x: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_member(x: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delq_x(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delv_x(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delete_x(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_copy(lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delq(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delv(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delete(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delq1_x(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delv1_x(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delete1_x(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_filter(pred: SCM, list: SCM) -> SCM;
}
extern "C" {
    pub fn scm_filter_x(pred: SCM, list: SCM) -> SCM;
}
extern "C" {
    pub fn scm_copy_tree(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_finite_list_copy(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_list();
}
extern "C" {
    pub fn scm_parse_path(path: SCM, tail: SCM) -> SCM;
}
extern "C" {
    pub fn scm_parse_path_with_ellipsis(path: SCM, base: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_load(filename: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_primitive_load(filename: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_sys_package_data_dir() -> SCM;
}
extern "C" {
    pub fn scm_sys_library_dir() -> SCM;
}
extern "C" {
    pub fn scm_sys_site_dir() -> SCM;
}
extern "C" {
    pub fn scm_sys_global_site_dir() -> SCM;
}
extern "C" {
    pub fn scm_sys_site_ccache_dir() -> SCM;
}
extern "C" {
    pub fn scm_search_path(path: SCM, filename: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_search_load_path(filename: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_load_path(filename_and_exception_on_not_found: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_primitive_load_path(filename: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_sys_warn_auto_compilation_enabled() -> SCM;
}
extern "C" {
    pub fn scm_init_load_path();
}
extern "C" {
    pub fn scm_init_load();
}
extern "C" {
    pub fn scm_init_load_should_auto_compile();
}
extern "C" {
    pub fn scm_init_eval_in_scheme();
}
extern "C" {
    pub fn scm_i_mirror_backslashes(
        path: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type scm_t_macro_primitive =
    ::std::option::Option<unsafe extern "C" fn(arg1: SCM, arg2: SCM) -> SCM>;
extern "C" {
    pub fn scm_make_syntax_transformer(
        name_or_existing_definition: SCM,
        type_: SCM,
        binding: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_macro_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_macro_type(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_macro_name(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_macro_binding(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_macro_transformer(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_make_primitive_macro(
        name: *const ::std::os::raw::c_char,
        fn_: scm_t_macro_primitive,
    ) -> SCM;
}
extern "C" {
    pub fn scm_i_macro_primitive(m: SCM) -> scm_t_macro_primitive;
}
extern "C" {
    pub fn scm_init_macros();
}
extern "C" {
    pub static mut scm_tc16_malloc: scm_t_bits;
}
extern "C" {
    pub fn scm_malloc_obj(n: size_t) -> SCM;
}
extern "C" {
    pub fn scm_init_mallocs();
}
extern "C" {
    pub static mut scm_module_system_booted_p: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut scm_module_tag: scm_t_bits;
}
extern "C" {
    pub fn scm_current_module() -> SCM;
}
extern "C" {
    pub fn scm_the_root_module() -> SCM;
}
extern "C" {
    pub fn scm_interaction_environment() -> SCM;
}
extern "C" {
    pub fn scm_set_current_module(module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_call_with_current_module(
        module: SCM,
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> SCM>,
        data: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_dynwind_current_module(module: SCM);
}
extern "C" {
    pub fn scm_module_variable(module: SCM, sym: SCM) -> SCM;
}
extern "C" {
    pub fn scm_module_local_variable(module: SCM, sym: SCM) -> SCM;
}
extern "C" {
    pub fn scm_module_ensure_local_variable(module: SCM, sym: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_lookup(name: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_c_define(name: *const ::std::os::raw::c_char, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lookup(symbol: SCM) -> SCM;
}
extern "C" {
    pub fn scm_define(symbol: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_module_lookup(module: SCM, name: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_c_module_define(module: SCM, name: *const ::std::os::raw::c_char, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_module_lookup(module: SCM, symbol: SCM) -> SCM;
}
extern "C" {
    pub fn scm_module_define(module: SCM, symbol: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_module_export(module: SCM, symbol_list: SCM) -> SCM;
}
extern "C" {
    pub fn scm_module_reverse_lookup(module: SCM, variable: SCM) -> SCM;
}
extern "C" {
    pub fn scm_public_variable(module_name: SCM, name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_private_variable(module_name: SCM, name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_public_variable(
        module_name: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> SCM;
}
extern "C" {
    pub fn scm_c_private_variable(
        module_name: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> SCM;
}
extern "C" {
    pub fn scm_public_lookup(module_name: SCM, name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_private_lookup(module_name: SCM, name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_public_lookup(
        module_name: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> SCM;
}
extern "C" {
    pub fn scm_c_private_lookup(
        module_name: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> SCM;
}
extern "C" {
    pub fn scm_public_ref(module_name: SCM, name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_private_ref(module_name: SCM, name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_public_ref(
        module_name: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> SCM;
}
extern "C" {
    pub fn scm_c_private_ref(
        module_name: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> SCM;
}
extern "C" {
    pub fn scm_c_resolve_module(name: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_resolve_module(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_define_module(
        name: *const ::std::os::raw::c_char,
        init: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        data: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_c_use_module(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_c_export(name: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn scm_module_public_interface(module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_module_import_interface(module: SCM, sym: SCM) -> SCM;
}
extern "C" {
    pub fn scm_module_transformer(module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_current_module_transformer() -> SCM;
}
extern "C" {
    pub fn scm_get_pre_modules_obarray() -> SCM;
}
extern "C" {
    pub fn scm_modules_prehistory();
}
extern "C" {
    pub fn scm_init_modules();
}
extern "C" {
    pub fn scm_gethost(host: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getnet(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getproto(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getserv(name: SCM, proto: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sethost(arg: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setnet(arg: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setproto(arg: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setserv(arg: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getaddrinfo(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM, arg5: SCM, arg6: SCM)
        -> SCM;
}
extern "C" {
    pub fn scm_gai_strerror(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_net_db();
}
extern "C" {
    pub fn scm_object_properties(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_object_properties_x(obj: SCM, plist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_object_property(obj: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_object_property_x(obj: SCM, key: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_objprop();
}
extern "C" {
    pub fn scm_cons(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cons2(w: SCM, x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pair_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_car(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_car_x(pair: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_cdr_x(pair: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cddr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cadr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdddr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cddar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdadr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdaar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caddr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cadar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caadr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caaar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cddddr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdddar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cddadr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cddaar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdaddr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdadar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdaadr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdaaar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cadddr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caddar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cadadr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cadaar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caaddr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caadar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caaadr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caaaar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_pairs();
}
extern "C" {
    pub fn scm_tcsetpgrp(port: SCM, pgid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_tcgetpgrp(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ctermid() -> SCM;
}
extern "C" {
    pub fn scm_setsid() -> SCM;
}
extern "C" {
    pub fn scm_getsid(pid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setpgid(pid: SCM, pgid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pipe() -> SCM;
}
extern "C" {
    pub fn scm_getgroups() -> SCM;
}
extern "C" {
    pub fn scm_setgroups(groups: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getpgrp() -> SCM;
}
extern "C" {
    pub fn scm_getpwuid(user: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setpwent(arg: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getgrgid(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setgrent(arg: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getrlimit(resource: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setrlimit(resource: SCM, soft: SCM, hard: SCM) -> SCM;
}
extern "C" {
    pub fn scm_kill(pid: SCM, sig: SCM) -> SCM;
}
extern "C" {
    pub fn scm_waitpid(pid: SCM, options: SCM) -> SCM;
}
extern "C" {
    pub fn scm_status_exit_val(status: SCM) -> SCM;
}
extern "C" {
    pub fn scm_status_term_sig(status: SCM) -> SCM;
}
extern "C" {
    pub fn scm_status_stop_sig(status: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getppid() -> SCM;
}
extern "C" {
    pub fn scm_getuid() -> SCM;
}
extern "C" {
    pub fn scm_getgid() -> SCM;
}
extern "C" {
    pub fn scm_geteuid() -> SCM;
}
extern "C" {
    pub fn scm_getegid() -> SCM;
}
extern "C" {
    pub fn scm_setuid(uid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setgid(gid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_seteuid(euid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setegid(egid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ttyname(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_execl(filename: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_execlp(filename: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_execle(filename: SCM, env: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fork() -> SCM;
}
extern "C" {
    pub fn scm_uname() -> SCM;
}
extern "C" {
    pub fn scm_environ(env: SCM) -> SCM;
}
extern "C" {
    pub fn scm_tmpnam() -> SCM;
}
extern "C" {
    pub fn scm_mkstemp(tmpl: SCM) -> SCM;
}
extern "C" {
    pub fn scm_tmpfile() -> SCM;
}
extern "C" {
    pub fn scm_open_pipe(pipestr: SCM, modes: SCM) -> SCM;
}
extern "C" {
    pub fn scm_close_pipe(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_system_star(cmds: SCM) -> SCM;
}
extern "C" {
    pub fn scm_utime(
        pathname: SCM,
        actime: SCM,
        modtime: SCM,
        actimens: SCM,
        modtimens: SCM,
        flags: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_access(path: SCM, how: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getpid() -> SCM;
}
extern "C" {
    pub fn scm_putenv(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setlocale(category: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_mknod(path: SCM, type_: SCM, perms: SCM, dev: SCM) -> SCM;
}
extern "C" {
    pub fn scm_nice(incr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sync() -> SCM;
}
extern "C" {
    pub fn scm_crypt(key: SCM, salt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_chroot(path: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getlogin() -> SCM;
}
extern "C" {
    pub fn scm_getpriority(which: SCM, who: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setpriority(which: SCM, who: SCM, prio: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getpass(prompt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_flock(file: SCM, operation: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sethostname(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gethostname() -> SCM;
}
extern "C" {
    pub fn scm_getaffinity(pid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setaffinity(pid: SCM, cpu_set: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_posix();
}
extern "C" {
    pub static mut scm_i_locale_mutex: pthread_mutex_t;
}
extern "C" {
    pub static mut scm_sym_name: SCM;
}
extern "C" {
    pub static mut scm_sym_arity: SCM;
}
extern "C" {
    pub static mut scm_sym_system_procedure: SCM;
}
extern "C" {
    pub fn scm_i_procedure_arity(
        proc_: SCM,
        req: *mut ::std::os::raw::c_int,
        opt: *mut ::std::os::raw::c_int,
        rest: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_set_procedure_minimum_arity_x(proc_: SCM, req: SCM, opt: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_procedure_minimum_arity(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_procedure_properties(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_procedure_properties_x(proc_: SCM, alist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_procedure_property(proc_: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_procedure_property_x(proc_: SCM, key: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_procprop();
}
extern "C" {
    pub static mut scm_tc16_promise: scm_t_bits;
}
extern "C" {
    pub fn scm_make_promise(thunk: SCM) -> SCM;
}
extern "C" {
    pub fn scm_force(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_promise_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_promises();
}
extern "C" {
    pub fn scm_eof_object() -> SCM;
}
extern "C" {
    pub fn scm_open_bytevector_input_port(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_custom_binary_input_port(
        arg1: SCM,
        arg2: SCM,
        arg3: SCM,
        arg4: SCM,
        arg5: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_get_u8(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lookahead_u8(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_get_bytevector_n(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_get_bytevector_n_x(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_get_bytevector_some(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_get_bytevector_all(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_put_u8(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_put_bytevector(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_open_bytevector_output_port(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_custom_binary_output_port(
        arg1: SCM,
        arg2: SCM,
        arg3: SCM,
        arg4: SCM,
        arg5: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_get_string_n_x(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_r6rs_ports();
}
extern "C" {
    pub fn scm_register_r6rs_ports();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_rstate {
    pub rng: *mut scm_t_rng,
    pub normal_next: f64,
}
#[test]
fn bindgen_test_layout_scm_t_rstate() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_rstate>(),
        16usize,
        concat!("Size of: ", stringify!(scm_t_rstate))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_rstate>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_rstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_rstate>())).rng as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_rstate),
            "::",
            stringify!(rng)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_rstate>())).normal_next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_rstate),
            "::",
            stringify!(normal_next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_rng {
    pub rstate_size: size_t,
    pub random_bits:
        ::std::option::Option<unsafe extern "C" fn(state: *mut scm_t_rstate) -> scm_t_uint32>,
    pub init_rstate: ::std::option::Option<
        unsafe extern "C" fn(
            state: *mut scm_t_rstate,
            seed: *const ::std::os::raw::c_char,
            n: ::std::os::raw::c_int,
        ),
    >,
    pub copy_rstate:
        ::std::option::Option<unsafe extern "C" fn(state: *mut scm_t_rstate) -> *mut scm_t_rstate>,
    pub from_datum:
        ::std::option::Option<unsafe extern "C" fn(state: *mut scm_t_rstate, datum: SCM)>,
    pub to_datum: ::std::option::Option<unsafe extern "C" fn(state: *mut scm_t_rstate) -> SCM>,
}
#[test]
fn bindgen_test_layout_scm_t_rng() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_rng>(),
        48usize,
        concat!("Size of: ", stringify!(scm_t_rng))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_rng>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_rng))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_rng>())).rstate_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_rng),
            "::",
            stringify!(rstate_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_rng>())).random_bits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_rng),
            "::",
            stringify!(random_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_rng>())).init_rstate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_rng),
            "::",
            stringify!(init_rstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_rng>())).copy_rstate as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_rng),
            "::",
            stringify!(copy_rstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_rng>())).from_datum as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_rng),
            "::",
            stringify!(from_datum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_rng>())).to_datum as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_rng),
            "::",
            stringify!(to_datum)
        )
    );
}
extern "C" {
    pub static mut scm_the_rng: scm_t_rng;
}
extern "C" {
    pub fn scm_c_make_rstate(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut scm_t_rstate;
}
extern "C" {
    pub fn scm_c_rstate_from_datum(datum: SCM) -> *mut scm_t_rstate;
}
extern "C" {
    pub fn scm_c_default_rstate() -> *mut scm_t_rstate;
}
extern "C" {
    pub fn scm_c_uniform01(arg1: *mut scm_t_rstate) -> f64;
}
extern "C" {
    pub fn scm_c_normal01(arg1: *mut scm_t_rstate) -> f64;
}
extern "C" {
    pub fn scm_c_exp1(arg1: *mut scm_t_rstate) -> f64;
}
extern "C" {
    pub fn scm_c_random(arg1: *mut scm_t_rstate, m: scm_t_uint32) -> scm_t_uint32;
}
extern "C" {
    pub fn scm_c_random64(state: *mut scm_t_rstate, m: scm_t_uint64) -> scm_t_uint64;
}
extern "C" {
    pub fn scm_c_random_bignum(arg1: *mut scm_t_rstate, m: SCM) -> SCM;
}
extern "C" {
    pub static mut scm_tc16_rstate: scm_t_bits;
}
extern "C" {
    pub static mut scm_masktab: [::std::os::raw::c_uchar; 256usize];
}
extern "C" {
    pub static mut scm_var_random_state: SCM;
}
extern "C" {
    pub fn scm_random(n: SCM, state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_copy_random_state(state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_seed_to_random_state(seed: SCM) -> SCM;
}
extern "C" {
    pub fn scm_datum_to_random_state(datum: SCM) -> SCM;
}
extern "C" {
    pub fn scm_random_state_to_datum(state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_random_state_from_platform() -> SCM;
}
extern "C" {
    pub fn scm_random_uniform(state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_random_solid_sphere_x(v: SCM, state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_random_hollow_sphere_x(v: SCM, state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_random_normal(state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_random_normal_vector_x(v: SCM, state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_random_exp(state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_random();
}
extern "C" {
    pub fn scm_i_random_bytes_from_platform(buf: *mut ::std::os::raw::c_uchar, len: size_t);
}
extern "C" {
    pub static mut scm_sym_dot: SCM;
}
extern "C" {
    pub fn scm_read_options(setting: SCM) -> SCM;
}
extern "C" {
    pub fn scm_read(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_read_hash_extend(chr: SCM, proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_scan_for_encoding(port: SCM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_file_encoding(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_input_error(
        func: *const ::std::os::raw::c_char,
        port: SCM,
        message: *const ::std::os::raw::c_char,
        arg: SCM,
    );
}
extern "C" {
    pub fn scm_init_read();
}
extern "C" {
    pub fn scm_sigaction(signum: SCM, handler: SCM, flags: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sigaction_for_thread(signum: SCM, handler: SCM, flags: SCM, thread: SCM) -> SCM;
}
extern "C" {
    pub fn scm_restore_signals() -> SCM;
}
extern "C" {
    pub fn scm_alarm(i: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setitimer(
        which_timer: SCM,
        interval_seconds: SCM,
        interval_microseconds: SCM,
        value_seconds: SCM,
        value_microseconds: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_getitimer(which_timer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pause() -> SCM;
}
extern "C" {
    pub fn scm_sleep(i: SCM) -> SCM;
}
extern "C" {
    pub fn scm_usleep(i: SCM) -> SCM;
}
extern "C" {
    pub fn scm_raise(sig: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_scmsigs();
}
extern "C" {
    pub fn scm_i_close_signal_pipe();
}
extern "C" {
    pub fn scm_i_ensure_signal_delivery_thread();
}
extern "C" {
    pub static mut scm_i_signal_delivery_thread: *mut scm_i_thread;
}
extern "C" {
    pub fn scm_find_executable(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_find_impl_file(
        exec_path: *mut ::std::os::raw::c_char,
        generic_name: *const ::std::os::raw::c_char,
        initname: *const ::std::os::raw::c_char,
        sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_get_meta_args(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_count_argv(argv: *mut *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_shell_usage(fatal: ::std::os::raw::c_int, message: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_compile_shell_switches(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> SCM;
}
extern "C" {
    pub fn scm_shell(argc: ::std::os::raw::c_int, argv: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub static mut scm_usage_name: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_set_boot_program_arguments(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn scm_init_script();
}
extern "C" {
    pub fn scm_system(cmd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getenv(nam: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_exit(status: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive__exit(status: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_simpos();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_smob_descriptor {
    pub name: *const ::std::os::raw::c_char,
    pub size: size_t,
    pub mark: ::std::option::Option<unsafe extern "C" fn(arg1: SCM) -> SCM>,
    pub free: ::std::option::Option<unsafe extern "C" fn(arg1: SCM) -> size_t>,
    pub print: ::std::option::Option<
        unsafe extern "C" fn(
            exp: SCM,
            port: SCM,
            pstate: *mut scm_print_state,
        ) -> ::std::os::raw::c_int,
    >,
    pub equalp: ::std::option::Option<unsafe extern "C" fn(arg1: SCM, arg2: SCM) -> SCM>,
    pub apply: scm_t_subr,
    pub apply_trampoline_objcode: SCM,
}
#[test]
fn bindgen_test_layout_scm_smob_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<scm_smob_descriptor>(),
        64usize,
        concat!("Size of: ", stringify!(scm_smob_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_smob_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_smob_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_smob_descriptor>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_smob_descriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_smob_descriptor>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_smob_descriptor),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_smob_descriptor>())).mark as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_smob_descriptor),
            "::",
            stringify!(mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_smob_descriptor>())).free as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_smob_descriptor),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_smob_descriptor>())).print as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_smob_descriptor),
            "::",
            stringify!(print)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_smob_descriptor>())).equalp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_smob_descriptor),
            "::",
            stringify!(equalp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_smob_descriptor>())).apply as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_smob_descriptor),
            "::",
            stringify!(apply)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<scm_smob_descriptor>())).apply_trampoline_objcode as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_smob_descriptor),
            "::",
            stringify!(apply_trampoline_objcode)
        )
    );
}
extern "C" {
    pub static mut scm_numsmob: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut scm_smobs: [scm_smob_descriptor; 0usize];
}
extern "C" {
    pub fn scm_i_new_smob(tc: scm_t_bits, arg1: scm_t_bits) -> SCM;
}
extern "C" {
    pub fn scm_i_new_double_smob(
        tc: scm_t_bits,
        arg1: scm_t_bits,
        arg2: scm_t_bits,
        arg3: scm_t_bits,
    ) -> SCM;
}
extern "C" {
    pub fn scm_i_finalize_smob(ptr: *mut ::std::os::raw::c_void, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_i_new_smob_with_mark_proc(
        tc: scm_t_bits,
        arg1: scm_t_bits,
        arg2: scm_t_bits,
        arg3: scm_t_bits,
    ) -> SCM;
}
extern "C" {
    pub fn scm_mark0(ptr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_markcdr(ptr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_free0(ptr: SCM) -> size_t;
}
extern "C" {
    pub fn scm_smob_print(
        exp: SCM,
        port: SCM,
        pstate: *mut scm_print_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_make_smob_type(name: *const ::std::os::raw::c_char, size: size_t) -> scm_t_bits;
}
extern "C" {
    pub fn scm_set_smob_mark(
        tc: scm_t_bits,
        mark: ::std::option::Option<unsafe extern "C" fn(arg1: SCM) -> SCM>,
    );
}
extern "C" {
    pub fn scm_set_smob_free(
        tc: scm_t_bits,
        free: ::std::option::Option<unsafe extern "C" fn(arg1: SCM) -> size_t>,
    );
}
extern "C" {
    pub fn scm_set_smob_print(
        tc: scm_t_bits,
        print: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: SCM,
                arg2: SCM,
                arg3: *mut scm_print_state,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn scm_set_smob_equalp(
        tc: scm_t_bits,
        equalp: ::std::option::Option<unsafe extern "C" fn(arg1: SCM, arg2: SCM) -> SCM>,
    );
}
extern "C" {
    pub fn scm_set_smob_apply(
        tc: scm_t_bits,
        apply: scm_t_subr,
        req: ::std::os::raw::c_uint,
        opt: ::std::os::raw::c_uint,
        rst: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn scm_assert_smob_type(tag: scm_t_bits, val: SCM);
}
extern "C" {
    pub fn scm_make_smob(tc: scm_t_bits) -> SCM;
}
extern "C" {
    pub fn scm_smob_prehistory();
}
extern "C" {
    pub fn scm_inet_aton(address: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inet_ntoa(inetid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inet_netof(address: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lnaof(address: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inet_makeaddr(net: SCM, lna: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inet_pton(family: SCM, address: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inet_ntop(family: SCM, address: SCM) -> SCM;
}
extern "C" {
    pub fn scm_socket(family: SCM, style: SCM, proto: SCM) -> SCM;
}
extern "C" {
    pub fn scm_socketpair(family: SCM, style: SCM, proto: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getsockopt(sfd: SCM, level: SCM, optname: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setsockopt(sfd: SCM, level: SCM, optname: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_shutdown(sfd: SCM, how: SCM) -> SCM;
}
extern "C" {
    pub fn scm_connect(sockfd: SCM, fam: SCM, address: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bind(sockfd: SCM, fam: SCM, address: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_listen(sfd: SCM, backlog: SCM) -> SCM;
}
extern "C" {
    pub fn scm_accept(sockfd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getsockname(sockfd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getpeername(sockfd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_recv(sockfd: SCM, buff_or_size: SCM, flags: SCM) -> SCM;
}
extern "C" {
    pub fn scm_send(sockfd: SCM, message: SCM, flags: SCM) -> SCM;
}
extern "C" {
    pub fn scm_recvfrom(
        sockfd: SCM,
        buff_or_size: SCM,
        flags: SCM,
        offset: SCM,
        length: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_sendto(
        sockfd: SCM,
        message: SCM,
        fam: SCM,
        address: SCM,
        args_and_flags: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_init_socket();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn scm_from_sockaddr(address: *const sockaddr, addr_size: ::std::os::raw::c_uint) -> SCM;
}
extern "C" {
    pub fn scm_to_sockaddr(address: SCM, adress_size: *mut size_t) -> *mut sockaddr;
}
extern "C" {
    pub fn scm_c_make_socket_address(
        family: SCM,
        address: SCM,
        args: SCM,
        address_size: *mut size_t,
    ) -> *mut sockaddr;
}
extern "C" {
    pub fn scm_make_socket_address(family: SCM, address: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_restricted_vector_sort_x(vec: SCM, less: SCM, startpos: SCM, endpos: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sorted_p(ls: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_merge(ls1: SCM, ls2: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_merge_x(ls1: SCM, ls2: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sort(ls: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sort_x(ls: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_stable_sort(ls: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_stable_sort_x(ls: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sort_list(ls: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sort_list_x(ls: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_sort();
}
extern "C" {
    pub static mut scm_tc16_srcprops: scm_t_bits;
}
extern "C" {
    pub static mut scm_sym_filename: SCM;
}
extern "C" {
    pub static mut scm_sym_copy: SCM;
}
extern "C" {
    pub static mut scm_sym_line: SCM;
}
extern "C" {
    pub static mut scm_sym_column: SCM;
}
extern "C" {
    pub fn scm_supports_source_properties_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_srcprops(
        line: ::std::os::raw::c_long,
        col: ::std::os::raw::c_int,
        fname: SCM,
        copy: SCM,
        plist: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_source_property(obj: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_source_property_x(obj: SCM, key: SCM, datum: SCM) -> SCM;
}
extern "C" {
    pub fn scm_source_properties(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_source_properties_x(obj: SCM, props: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_has_source_properties(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_set_source_properties_x(
        obj: SCM,
        line: ::std::os::raw::c_long,
        col: ::std::os::raw::c_int,
        fname: SCM,
    );
}
extern "C" {
    pub fn scm_cons_source(xorig: SCM, x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_srcprop();
}
extern "C" {
    pub static mut scm_stack_checking_enabled_p: ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_report_stack_overflow();
}
extern "C" {
    pub fn scm_stack_size(start: *mut SCM_STACKITEM) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scm_stack_report();
}
extern "C" {
    pub fn scm_sys_get_stack_size() -> SCM;
}
extern "C" {
    pub fn scm_init_stackchk();
}
extern "C" {
    pub static mut scm_c_time_units_per_second: ::std::os::raw::c_long;
}
extern "C" {
    pub fn scm_c_get_internal_run_time() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scm_get_internal_real_time() -> SCM;
}
extern "C" {
    pub fn scm_get_internal_run_time() -> SCM;
}
extern "C" {
    pub fn scm_current_time() -> SCM;
}
extern "C" {
    pub fn scm_gettimeofday() -> SCM;
}
extern "C" {
    pub fn scm_localtime(time: SCM, zone: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gmtime(time: SCM) -> SCM;
}
extern "C" {
    pub fn scm_mktime(sbd_time: SCM, zone: SCM) -> SCM;
}
extern "C" {
    pub fn scm_tzset() -> SCM;
}
extern "C" {
    pub fn scm_times() -> SCM;
}
extern "C" {
    pub fn scm_strftime(format: SCM, stime: SCM) -> SCM;
}
extern "C" {
    pub fn scm_strptime(format: SCM, string: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_stime();
}
extern "C" {
    pub fn scm_string_null_p(s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_any(pred: SCM, s: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_every(pred: SCM, s: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_tabulate(proc_: SCM, len: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_to_list(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_to_list(str_: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_reverse_list_to_string(chrs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_join(ls: SCM, delimiter: SCM, grammar: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_copy(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_copy_x(target: SCM, tstart: SCM, s: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_move_x(str1: SCM, start1: SCM, end1: SCM, str2: SCM, start2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_take(s: SCM, n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_drop(s: SCM, n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_take_right(s: SCM, n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_drop_right(s: SCM, n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_pad(s: SCM, len: SCM, chr: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_pad_right(s: SCM, len: SCM, chr: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_trim(s: SCM, char_pred: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_trim_right(s: SCM, char_pred: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_trim_both(s: SCM, char_pred: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_fill_x(str_: SCM, chr: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_fill_x(str_: SCM, chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_compare(
        s1: SCM,
        s2: SCM,
        proc_lt: SCM,
        proc_eq: SCM,
        proc_gt: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_compare_ci(
        s1: SCM,
        s2: SCM,
        proc_lt: SCM,
        proc_eq: SCM,
        proc_gt: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_eq(s1: SCM, s2: SCM, start1: SCM, end1: SCM, start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_neq(s1: SCM, s2: SCM, start1: SCM, end1: SCM, start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_lt(s1: SCM, s2: SCM, start1: SCM, end1: SCM, start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_gt(s1: SCM, s2: SCM, start1: SCM, end1: SCM, start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_le(s1: SCM, s2: SCM, start1: SCM, end1: SCM, start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ge(s1: SCM, s2: SCM, start1: SCM, end1: SCM, start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_eq(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_neq(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_lt(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_gt(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_le(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_ge(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_substring_hash(s: SCM, bound: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_hash_ci(s: SCM, bound: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_prefix_length(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_prefix_length_ci(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_suffix_length(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_suffix_length_ci(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_prefix_p(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_prefix_ci_p(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_suffix_p(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_suffix_ci_p(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_index(s: SCM, char_pred: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_index_right(s: SCM, char_pred: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_rindex(s: SCM, char_pred: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_skip(s: SCM, char_pred: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_skip_right(s: SCM, char_pred: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_count(s: SCM, char_pred: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_contains(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_contains_ci(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_substring_upcase_x(str_: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_upcase(str_: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_upcase_x(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_upcase(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_downcase_x(str_: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_downcase(str_: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_downcase_x(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_downcase(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_titlecase_x(str_: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_titlecase(str_: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_capitalize_x(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_capitalize(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_reverse(str_: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_reverse_x(str_: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_append_shared(ls: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_concatenate(ls: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_concatenate_shared(ls: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_concatenate_reverse(ls: SCM, final_string: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_concatenate_reverse_shared(ls: SCM, final_string: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_map(proc_: SCM, s: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_map_x(proc_: SCM, s: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_fold(kons: SCM, knil: SCM, s: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_fold_right(kons: SCM, knil: SCM, s: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_unfold(p: SCM, f: SCM, g: SCM, seed: SCM, base: SCM, make_final: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_unfold_right(
        p: SCM,
        f: SCM,
        g: SCM,
        seed: SCM,
        base: SCM,
        make_final: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_for_each(proc_: SCM, s: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_for_each_index(proc_: SCM, s: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_xsubstring(s: SCM, from: SCM, to: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_xcopy_x(
        target: SCM,
        tstart: SCM,
        s: SCM,
        sfrom: SCM,
        sto: SCM,
        start: SCM,
        end: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_replace(
        s1: SCM,
        s2: SCM,
        start1: SCM,
        end1: SCM,
        start2: SCM,
        end2: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_string_tokenize(s: SCM, token_char: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_split(s: SCM, char_pred: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_filter(char_pred: SCM, s: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_delete(char_pred: SCM, s: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_srfi_13();
}
extern "C" {
    pub fn scm_init_srfi_13_14();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_char_range {
    pub lo: scm_t_wchar,
    pub hi: scm_t_wchar,
}
#[test]
fn bindgen_test_layout_scm_t_char_range() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_char_range>(),
        8usize,
        concat!("Size of: ", stringify!(scm_t_char_range))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_char_range>(),
        4usize,
        concat!("Alignment of ", stringify!(scm_t_char_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_char_range>())).lo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_char_range),
            "::",
            stringify!(lo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_char_range>())).hi as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_char_range),
            "::",
            stringify!(hi)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_char_set {
    pub len: size_t,
    pub ranges: *mut scm_t_char_range,
}
#[test]
fn bindgen_test_layout_scm_t_char_set() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_char_set>(),
        16usize,
        concat!("Size of: ", stringify!(scm_t_char_set))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_char_set>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_char_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_char_set>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_char_set),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_char_set>())).ranges as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_char_set),
            "::",
            stringify!(ranges)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_char_set_cursor {
    pub range: size_t,
    pub n: scm_t_wchar,
}
#[test]
fn bindgen_test_layout_scm_t_char_set_cursor() {
    assert_eq!(
        ::std::mem::size_of::<scm_t_char_set_cursor>(),
        16usize,
        concat!("Size of: ", stringify!(scm_t_char_set_cursor))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_t_char_set_cursor>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_t_char_set_cursor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_char_set_cursor>())).range as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_char_set_cursor),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_t_char_set_cursor>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_t_char_set_cursor),
            "::",
            stringify!(n)
        )
    );
}
extern "C" {
    pub static mut scm_tc16_charset: ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_charset_get(cs: *mut scm_t_char_set, n: scm_t_wchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_charset_set(cs: *mut scm_t_char_set, n: scm_t_wchar);
}
extern "C" {
    pub fn scm_i_charset_unset(cs: *mut scm_t_char_set, n: scm_t_wchar);
}
extern "C" {
    pub fn scm_char_set_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_eq(char_sets: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_leq(char_sets: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_hash(cs: SCM, bound: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_cursor(cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_ref(cs: SCM, cursor: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_cursor_next(cs: SCM, cursor: SCM) -> SCM;
}
extern "C" {
    pub fn scm_end_of_char_set_p(cursor: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_fold(kons: SCM, knil: SCM, cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_unfold(p: SCM, f: SCM, g: SCM, seed: SCM, base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_unfold_x(p: SCM, f: SCM, g: SCM, seed: SCM, base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_for_each(proc_: SCM, cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_map(proc_: SCM, cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_copy(cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set(rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_char_set(list: SCM, base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_char_set_x(list: SCM, base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_to_char_set(str_: SCM, base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_to_char_set_x(str_: SCM, base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_filter(pred: SCM, cs: SCM, base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_filter_x(pred: SCM, cs: SCM, base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ucs_range_to_char_set(lower: SCM, upper: SCM, error: SCM, base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ucs_range_to_char_set_x(lower: SCM, upper: SCM, error: SCM, base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_to_char_set(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_size(cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_count(pred: SCM, cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_to_list(cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_to_string(cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_contains_p(cs: SCM, ch: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_every(pred: SCM, cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_any(pred: SCM, cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_adjoin(cs: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_delete(cs: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_adjoin_x(cs: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_delete_x(cs: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_complement(cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_union(rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_intersection(rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_difference(cs1: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_xor(rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_diff_plus_intersection(cs1: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_complement_x(cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_union_x(cs1: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_intersection_x(cs1: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_difference_x(cs1: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_xor_x(cs1: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_diff_plus_intersection_x(cs1: SCM, cs2: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_char_set_dump(charset: SCM) -> SCM;
}
extern "C" {
    pub static mut scm_char_set_lower_case: SCM;
}
extern "C" {
    pub static mut scm_char_set_upper_case: SCM;
}
extern "C" {
    pub static mut scm_char_set_title_case: SCM;
}
extern "C" {
    pub static mut scm_char_set_letter: SCM;
}
extern "C" {
    pub static mut scm_char_set_digit: SCM;
}
extern "C" {
    pub static mut scm_char_set_letter_and_digit: SCM;
}
extern "C" {
    pub static mut scm_char_set_graphic: SCM;
}
extern "C" {
    pub static mut scm_char_set_printing: SCM;
}
extern "C" {
    pub static mut scm_char_set_whitespace: SCM;
}
extern "C" {
    pub static mut scm_char_set_iso_control: SCM;
}
extern "C" {
    pub static mut scm_char_set_punctuation: SCM;
}
extern "C" {
    pub static mut scm_char_set_symbol: SCM;
}
extern "C" {
    pub static mut scm_char_set_hex_digit: SCM;
}
extern "C" {
    pub static mut scm_char_set_blank: SCM;
}
extern "C" {
    pub static mut scm_char_set_ascii: SCM;
}
extern "C" {
    pub static mut scm_char_set_empty: SCM;
}
extern "C" {
    pub static mut scm_char_set_full: SCM;
}
extern "C" {
    pub fn scm_init_srfi_14();
}
extern "C" {
    pub fn scm_string_equal_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_equal_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_less_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_leq_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_gr_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_geq_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_less_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_leq_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_gr_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_geq_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_strorder();
}
extern "C" {
    pub static mut scm_tc16_strport: scm_t_bits;
}
extern "C" {
    pub fn scm_mkstrport(
        pos: SCM,
        str_: SCM,
        modes: ::std::os::raw::c_long,
        caller: *const ::std::os::raw::c_char,
    ) -> SCM;
}
extern "C" {
    pub fn scm_strport_to_string(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_object_to_string(obj: SCM, printer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_with_output_string(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_with_input_string(str_: SCM, proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_open_input_string(str_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_open_output_string() -> SCM;
}
extern "C" {
    pub fn scm_get_output_string(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_read_string(expr: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_c_eval_string(expr: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_c_eval_string_in_module(expr: *const ::std::os::raw::c_char, module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_eval_string(string: SCM) -> SCM;
}
extern "C" {
    pub fn scm_eval_string_in_module(string: SCM, module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_strports();
}
extern "C" {
    pub fn scm_symbol_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_interned_p(sym: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_symbol(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_to_string(s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_to_symbol(s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_to_symbol(s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_fref(s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_pref(s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_fset_x(s: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_pset_x(s: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_hash(s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gensym(prefix: SCM) -> SCM;
}
extern "C" {
    pub fn scm_from_locale_symbol(str_: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_from_locale_symboln(str_: *const ::std::os::raw::c_char, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_take_locale_symbol(sym: *mut ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_take_locale_symboln(sym: *mut ::std::os::raw::c_char, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_from_latin1_symbol(str_: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_from_latin1_symboln(str_: *const ::std::os::raw::c_char, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_take_latin1_symbol(sym: *mut ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_take_latin1_symboln(sym: *mut ::std::os::raw::c_char, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_from_utf8_symbol(str_: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_from_utf8_symboln(str_: *const ::std::os::raw::c_char, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_take_utf8_symbol(sym: *mut ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_take_utf8_symboln(sym: *mut ::std::os::raw::c_char, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_i_hash_symbol(
        obj: SCM,
        n: ::std::os::raw::c_ulong,
        closure: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_symbols_prehistory();
}
extern "C" {
    pub fn scm_init_symbols();
}
extern "C" {
    pub fn scm_init_trees();
}
extern "C" {
    pub static mut scm_i_array_element_type_sizes: [size_t; 0usize];
}
extern "C" {
    pub fn scm_array_handle_uniform_element_size(h: *mut scm_t_array_handle) -> size_t;
}
extern "C" {
    pub fn scm_array_handle_uniform_element_bit_size(h: *mut scm_t_array_handle) -> size_t;
}
extern "C" {
    pub fn scm_array_handle_uniform_elements(
        h: *mut scm_t_array_handle,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_array_handle_uniform_writable_elements(
        h: *mut scm_t_array_handle,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_uniform_vector_p(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_uniform_vector_length(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_uniform_vector_element_type(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_uniform_vector_element_size(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_uniform_vector_ref(v: SCM, idx: SCM) -> SCM;
}
extern "C" {
    pub fn scm_uniform_vector_set_x(v: SCM, idx: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_uniform_vector_to_list(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_uniform_vector_read_x(v: SCM, port_or_fd: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_uniform_vector_write(v: SCM, port_or_fd: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_uniform_vector(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_uniform_vector_length(v: SCM) -> size_t;
}
extern "C" {
    pub fn scm_c_uniform_vector_ref(v: SCM, idx: size_t) -> SCM;
}
extern "C" {
    pub fn scm_c_uniform_vector_set_x(v: SCM, idx: size_t, val: SCM);
}
extern "C" {
    pub fn scm_uniform_vector_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_uniform_vector_writable_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_init_uniform();
}
extern "C" {
    pub static mut scm_values_vtable: SCM;
}
extern "C" {
    pub fn scm_i_extract_values_2(obj: SCM, p1: *mut SCM, p2: *mut SCM);
}
extern "C" {
    pub fn scm_values(args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_values(base: *mut SCM, n: size_t) -> SCM;
}
extern "C" {
    pub fn scm_c_nvalues(obj: SCM) -> size_t;
}
extern "C" {
    pub fn scm_c_value_ref(obj: SCM, idx: size_t) -> SCM;
}
extern "C" {
    pub fn scm_init_values();
}
extern "C" {
    pub fn scm_make_variable(init: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_undefined_variable() -> SCM;
}
extern "C" {
    pub fn scm_variable_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_variable_ref(var: SCM) -> SCM;
}
extern "C" {
    pub fn scm_variable_set_x(var: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_variable_unset_x(var: SCM) -> SCM;
}
extern "C" {
    pub fn scm_variable_bound_p(var: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_variable_print(var: SCM, port: SCM, pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_init_variable();
}
extern "C" {
    pub fn scm_make_srfi_4_vector(type_: SCM, len: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u8vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_u8vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_u8vector(data: *mut scm_t_uint8, n: size_t) -> SCM;
}
extern "C" {
    pub fn scm_u8vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u8vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u8vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u8vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u8vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_u8vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_u8vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_u8_elements(h: *mut scm_t_array_handle) -> *const scm_t_uint8;
}
extern "C" {
    pub fn scm_array_handle_u8_writable_elements(h: *mut scm_t_array_handle) -> *mut scm_t_uint8;
}
extern "C" {
    pub fn scm_u8vector_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *const scm_t_uint8;
}
extern "C" {
    pub fn scm_u8vector_writable_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *mut scm_t_uint8;
}
extern "C" {
    pub fn scm_s8vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_s8vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_s8vector(data: *mut scm_t_int8, n: size_t) -> SCM;
}
extern "C" {
    pub fn scm_s8vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s8vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s8vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s8vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s8vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_s8vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_s8vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_s8_elements(h: *mut scm_t_array_handle) -> *const scm_t_int8;
}
extern "C" {
    pub fn scm_array_handle_s8_writable_elements(h: *mut scm_t_array_handle) -> *mut scm_t_int8;
}
extern "C" {
    pub fn scm_s8vector_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *const scm_t_int8;
}
extern "C" {
    pub fn scm_s8vector_writable_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *mut scm_t_int8;
}
extern "C" {
    pub fn scm_u16vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_u16vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_u16vector(data: *mut scm_t_uint16, n: size_t) -> SCM;
}
extern "C" {
    pub fn scm_u16vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u16vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u16vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u16vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u16vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_u16vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_u16vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_u16_elements(h: *mut scm_t_array_handle) -> *const scm_t_uint16;
}
extern "C" {
    pub fn scm_array_handle_u16_writable_elements(h: *mut scm_t_array_handle) -> *mut scm_t_uint16;
}
extern "C" {
    pub fn scm_u16vector_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *const scm_t_uint16;
}
extern "C" {
    pub fn scm_u16vector_writable_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *mut scm_t_uint16;
}
extern "C" {
    pub fn scm_s16vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_s16vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_s16vector(data: *mut scm_t_int16, n: size_t) -> SCM;
}
extern "C" {
    pub fn scm_s16vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s16vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s16vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s16vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s16vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_s16vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_s16vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_s16_elements(h: *mut scm_t_array_handle) -> *const scm_t_int16;
}
extern "C" {
    pub fn scm_array_handle_s16_writable_elements(h: *mut scm_t_array_handle) -> *mut scm_t_int16;
}
extern "C" {
    pub fn scm_s16vector_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *const scm_t_int16;
}
extern "C" {
    pub fn scm_s16vector_writable_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *mut scm_t_int16;
}
extern "C" {
    pub fn scm_u32vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_u32vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_u32vector(data: *mut scm_t_uint32, n: size_t) -> SCM;
}
extern "C" {
    pub fn scm_u32vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u32vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u32vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u32vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u32vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_u32vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_u32vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_u32_elements(h: *mut scm_t_array_handle) -> *const scm_t_uint32;
}
extern "C" {
    pub fn scm_array_handle_u32_writable_elements(h: *mut scm_t_array_handle) -> *mut scm_t_uint32;
}
extern "C" {
    pub fn scm_u32vector_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *const scm_t_uint32;
}
extern "C" {
    pub fn scm_u32vector_writable_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *mut scm_t_uint32;
}
extern "C" {
    pub fn scm_s32vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_s32vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_s32vector(data: *mut scm_t_int32, n: size_t) -> SCM;
}
extern "C" {
    pub fn scm_s32vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s32vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s32vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s32vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s32vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_s32vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_s32vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_s32_elements(h: *mut scm_t_array_handle) -> *const scm_t_int32;
}
extern "C" {
    pub fn scm_array_handle_s32_writable_elements(h: *mut scm_t_array_handle) -> *mut scm_t_int32;
}
extern "C" {
    pub fn scm_s32vector_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *const scm_t_int32;
}
extern "C" {
    pub fn scm_s32vector_writable_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *mut scm_t_int32;
}
extern "C" {
    pub fn scm_u64vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_u64vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u64vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u64vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u64vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u64vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u64vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_u64vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_u64vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_u64vector(data: *mut scm_t_uint64, n: size_t) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_u64_elements(h: *mut scm_t_array_handle) -> *const scm_t_uint64;
}
extern "C" {
    pub fn scm_array_handle_u64_writable_elements(h: *mut scm_t_array_handle) -> *mut scm_t_uint64;
}
extern "C" {
    pub fn scm_u64vector_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *const scm_t_uint64;
}
extern "C" {
    pub fn scm_u64vector_writable_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *mut scm_t_uint64;
}
extern "C" {
    pub fn scm_s64vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_s64vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s64vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s64vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s64vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s64vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s64vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_s64vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_s64vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_s64vector(data: *mut scm_t_int64, n: size_t) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_s64_elements(h: *mut scm_t_array_handle) -> *const scm_t_int64;
}
extern "C" {
    pub fn scm_array_handle_s64_writable_elements(h: *mut scm_t_array_handle) -> *mut scm_t_int64;
}
extern "C" {
    pub fn scm_s64vector_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *const scm_t_int64;
}
extern "C" {
    pub fn scm_s64vector_writable_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *mut scm_t_int64;
}
extern "C" {
    pub fn scm_f32vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_f32vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_f32vector(data: *mut f32, n: size_t) -> SCM;
}
extern "C" {
    pub fn scm_f32vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_f32vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_f32vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_f32vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_f32vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_f32vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_f32vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_f32_elements(h: *mut scm_t_array_handle) -> *const f32;
}
extern "C" {
    pub fn scm_array_handle_f32_writable_elements(h: *mut scm_t_array_handle) -> *mut f32;
}
extern "C" {
    pub fn scm_f32vector_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *const f32;
}
extern "C" {
    pub fn scm_f32vector_writable_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *mut f32;
}
extern "C" {
    pub fn scm_f64vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_f64vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_f64vector(data: *mut f64, n: size_t) -> SCM;
}
extern "C" {
    pub fn scm_f64vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_f64vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_f64vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_f64vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_f64vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_f64vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_f64vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_f64_elements(h: *mut scm_t_array_handle) -> *const f64;
}
extern "C" {
    pub fn scm_array_handle_f64_writable_elements(h: *mut scm_t_array_handle) -> *mut f64;
}
extern "C" {
    pub fn scm_f64vector_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *const f64;
}
extern "C" {
    pub fn scm_f64vector_writable_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *mut f64;
}
extern "C" {
    pub fn scm_c32vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_c32vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_c32vector(data: *mut f32, n: size_t) -> SCM;
}
extern "C" {
    pub fn scm_c32vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c32vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c32vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c32vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c32vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_c32vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_c32vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_c32_elements(h: *mut scm_t_array_handle) -> *const f32;
}
extern "C" {
    pub fn scm_array_handle_c32_writable_elements(h: *mut scm_t_array_handle) -> *mut f32;
}
extern "C" {
    pub fn scm_c32vector_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *const f32;
}
extern "C" {
    pub fn scm_c32vector_writable_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *mut f32;
}
extern "C" {
    pub fn scm_c64vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_c64vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_c64vector(data: *mut f64, n: size_t) -> SCM;
}
extern "C" {
    pub fn scm_c64vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c64vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c64vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c64vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c64vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_c64vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_c64vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_c64_elements(h: *mut scm_t_array_handle) -> *const f64;
}
extern "C" {
    pub fn scm_array_handle_c64_writable_elements(h: *mut scm_t_array_handle) -> *mut f64;
}
extern "C" {
    pub fn scm_c64vector_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *const f64;
}
extern "C" {
    pub fn scm_c64vector_writable_elements(
        uvec: SCM,
        h: *mut scm_t_array_handle,
        lenp: *mut size_t,
        incp: *mut ssize_t,
    ) -> *mut f64;
}
extern "C" {
    pub fn scm_i_generalized_vector_type(vec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_uniform_vector_tag(uvec: SCM) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_uniform_vector_ref_proc(uvec: SCM) -> scm_i_t_array_ref;
}
extern "C" {
    pub fn scm_i_uniform_vector_set_proc(uvec: SCM) -> scm_i_t_array_set;
}
extern "C" {
    pub fn scm_uniform_element_size(obj: SCM) -> size_t;
}
extern "C" {
    pub fn scm_init_srfi_4();
}
extern "C" {
    pub fn scm_major_version() -> SCM;
}
extern "C" {
    pub fn scm_minor_version() -> SCM;
}
extern "C" {
    pub fn scm_micro_version() -> SCM;
}
extern "C" {
    pub fn scm_effective_version() -> SCM;
}
extern "C" {
    pub fn scm_version() -> SCM;
}
extern "C" {
    pub fn scm_init_version();
}
extern "C" {
    pub fn scm_make_soft_port(pv: SCM, modes: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_vports();
}
extern "C" {
    pub fn scm_print_exception(port: SCM, frame: SCM, key: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_display_error_message(message: SCM, args: SCM, port: SCM);
}
extern "C" {
    pub fn scm_i_display_error(
        frame: SCM,
        port: SCM,
        subr: SCM,
        message: SCM,
        args: SCM,
        rest: SCM,
    );
}
extern "C" {
    pub fn scm_display_error(
        frame: SCM,
        port: SCM,
        subr: SCM,
        message: SCM,
        args: SCM,
        rest: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_display_application(frame: SCM, port: SCM, indent: SCM) -> SCM;
}
extern "C" {
    pub fn scm_display_backtrace(stack: SCM, port: SCM, first: SCM, depth: SCM) -> SCM;
}
extern "C" {
    pub fn scm_display_backtrace_with_highlights(
        stack: SCM,
        port: SCM,
        first: SCM,
        depth: SCM,
        highlights: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_backtrace() -> SCM;
}
extern "C" {
    pub fn scm_backtrace_with_highlights(highlights: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_backtrace();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_objcode {
    pub len: scm_t_uint32,
    pub metalen: scm_t_uint32,
}
#[test]
fn bindgen_test_layout_scm_objcode() {
    assert_eq!(
        ::std::mem::size_of::<scm_objcode>(),
        8usize,
        concat!("Size of: ", stringify!(scm_objcode))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_objcode>(),
        4usize,
        concat!("Alignment of ", stringify!(scm_objcode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_objcode>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_objcode),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_objcode>())).metalen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_objcode),
            "::",
            stringify!(metalen)
        )
    );
}
extern "C" {
    pub fn scm_c_make_objcode_slice(parent: SCM, ptr: *const scm_t_uint8) -> SCM;
}
extern "C" {
    pub fn scm_load_objcode(file: SCM) -> SCM;
}
extern "C" {
    pub fn scm_objcode_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_objcode_meta(objcode: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytecode_to_objcode(bytecode: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytecode_to_native_objcode(bytecode: SCM) -> SCM;
}
extern "C" {
    pub fn scm_objcode_to_bytecode(objcode: SCM) -> SCM;
}
extern "C" {
    pub fn scm_write_objcode(objcode: SCM, port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_objcode_print(objcode: SCM, port: SCM, pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_bootstrap_objcodes();
}
extern "C" {
    pub fn scm_init_objcodes();
}
extern "C" {
    pub fn scm_make_program(objcode: SCM, objtable: SCM, free_variables: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_base(program: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_meta(program: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_bindings(program: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_sources(program: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_source(program: SCM, ip: SCM, sources: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_arities(program: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_objects(program: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_module(program: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_num_free_variables(program: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_free_variable_ref(program: SCM, i: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_free_variable_set_x(program: SCM, i: SCM, x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_objcode(program: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_program_properties(program: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_program_arity(
        program: SCM,
        req: *mut ::std::os::raw::c_int,
        opt: *mut ::std::os::raw::c_int,
        rest: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_program_print(program: SCM, port: SCM, pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_bootstrap_programs();
}
extern "C" {
    pub fn scm_init_programs();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_vm_frame {
    pub dynamic_link: *mut SCM,
    pub mv_return_address: *mut scm_t_uint8,
    pub return_address: *mut scm_t_uint8,
    pub program: SCM,
    pub stack: [SCM; 1usize],
}
#[test]
fn bindgen_test_layout_scm_vm_frame() {
    assert_eq!(
        ::std::mem::size_of::<scm_vm_frame>(),
        40usize,
        concat!("Size of: ", stringify!(scm_vm_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_vm_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_vm_frame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_vm_frame>())).dynamic_link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_vm_frame),
            "::",
            stringify!(dynamic_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_vm_frame>())).mv_return_address as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_vm_frame),
            "::",
            stringify!(mv_return_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_vm_frame>())).return_address as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_vm_frame),
            "::",
            stringify!(return_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_vm_frame>())).program as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_vm_frame),
            "::",
            stringify!(program)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_vm_frame>())).stack as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_vm_frame),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_frame {
    pub stack_holder: SCM,
    pub fp: *mut SCM,
    pub sp: *mut SCM,
    pub ip: *mut scm_t_uint8,
    pub offset: scm_t_ptrdiff,
}
#[test]
fn bindgen_test_layout_scm_frame() {
    assert_eq!(
        ::std::mem::size_of::<scm_frame>(),
        40usize,
        concat!("Size of: ", stringify!(scm_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<scm_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_frame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_frame>())).stack_holder as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_frame),
            "::",
            stringify!(stack_holder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_frame>())).fp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_frame),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_frame>())).sp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_frame),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_frame>())).ip as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_frame),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scm_frame>())).offset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_frame),
            "::",
            stringify!(offset)
        )
    );
}
extern "C" {
    pub fn scm_c_make_frame(
        stack_holder: SCM,
        fp: *mut SCM,
        sp: *mut SCM,
        ip: *mut scm_t_uint8,
        offset: scm_t_ptrdiff,
    ) -> SCM;
}
extern "C" {
    pub fn scm_frame_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_procedure(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_arguments(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_source(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_num_locals(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_local_ref(frame: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_local_set_x(frame: SCM, index: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_address(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_stack_pointer(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_instruction_pointer(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_return_address(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_mv_return_address(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_dynamic_link(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_previous(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_frame_print(frame: SCM, port: SCM, pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_init_frames();
}
extern "C" {
    pub static mut scm_stack_type: SCM;
}
extern "C" {
    pub fn scm_stack_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_stack(obj: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_stack_id(stack: SCM) -> SCM;
}
extern "C" {
    pub fn scm_stack_ref(stack: SCM, i: SCM) -> SCM;
}
extern "C" {
    pub fn scm_stack_length(stack: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_stacks();
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut scm_isymnames: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn scm_wta(
        arg: SCM,
        pos: *const ::std::os::raw::c_char,
        s_subr: *const ::std::os::raw::c_char,
    ) -> SCM;
}
extern "C" {
    pub fn scm_register_module_xxx(
        module_name: *mut ::std::os::raw::c_char,
        init_func: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn scm_registered_modules() -> SCM;
}
extern "C" {
    pub fn scm_clear_registered_modules() -> SCM;
}
extern "C" {
    pub fn scm_protect_object(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_unprotect_object(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_remember(ptr: *mut SCM);
}
extern "C" {
    pub fn scm_make_module(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ensure_user_module(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_load_scheme_module(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_close_all_ports_except(ports: SCM) -> SCM;
}
extern "C" {
    pub fn scm_makstr(len: size_t, arg1: ::std::os::raw::c_int) -> SCM;
}
extern "C" {
    pub fn scm_makfromstr(
        src: *const ::std::os::raw::c_char,
        len: size_t,
        arg1: ::std::os::raw::c_int,
    ) -> SCM;
}
extern "C" {
    pub fn scm_variable_set_name_hint(var: SCM, hint: SCM) -> SCM;
}
extern "C" {
    pub fn scm_builtin_variable(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_internal_with_fluids(
        fluids: SCM,
        vals: SCM,
        cproc: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> SCM,
        >,
        cdata: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_make_gsubr(
        name: *const ::std::os::raw::c_char,
        req: ::std::os::raw::c_int,
        opt: ::std::os::raw::c_int,
        rst: ::std::os::raw::c_int,
        fcn: scm_t_subr,
    ) -> SCM;
}
extern "C" {
    pub fn scm_make_gsubr_with_generic(
        name: *const ::std::os::raw::c_char,
        req: ::std::os::raw::c_int,
        opt: ::std::os::raw::c_int,
        rst: ::std::os::raw::c_int,
        fcn: scm_t_subr,
        gf: *mut SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_create_hook(
        name: *const ::std::os::raw::c_char,
        n_args: ::std::os::raw::c_int,
    ) -> SCM;
}
pub type scm_t_inner =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> SCM>;
extern "C" {
    pub fn scm_internal_dynamic_wind(
        before: scm_t_guard,
        inner: scm_t_inner,
        after: scm_t_guard,
        inner_data: *mut ::std::os::raw::c_void,
        guard_data: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_sloppy_memq(x: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sloppy_memv(x: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sloppy_member(x: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_read_and_eval_x(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_catching_errors(
        thunk: scm_t_subr,
        err_filter: scm_t_subr,
        closure: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_make_smob_type_mfpe(
        name: *mut ::std::os::raw::c_char,
        size: size_t,
        mark: ::std::option::Option<unsafe extern "C" fn(arg1: SCM) -> SCM>,
        free: ::std::option::Option<unsafe extern "C" fn(arg1: SCM) -> size_t>,
        print: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: SCM,
                arg2: SCM,
                arg3: *mut scm_print_state,
            ) -> ::std::os::raw::c_int,
        >,
        equalp: ::std::option::Option<unsafe extern "C" fn(arg1: SCM, arg2: SCM) -> SCM>,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scm_set_smob_mfpe(
        tc: ::std::os::raw::c_long,
        mark: ::std::option::Option<unsafe extern "C" fn(arg1: SCM) -> SCM>,
        free: ::std::option::Option<unsafe extern "C" fn(arg1: SCM) -> size_t>,
        print: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: SCM,
                arg2: SCM,
                arg3: *mut scm_print_state,
            ) -> ::std::os::raw::c_int,
        >,
        equalp: ::std::option::Option<unsafe extern "C" fn(arg1: SCM, arg2: SCM) -> SCM>,
    );
}
extern "C" {
    pub fn scm_smob_free(obj: SCM) -> size_t;
}
extern "C" {
    pub fn scm_strprint_obj(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_read_0str(expr: *mut ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_eval_0str(expr: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_i_object_chars(arg1: SCM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_object_length(arg1: SCM) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scm_sym2ovcell_soft(sym: SCM, obarray: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sym2ovcell(sym: SCM, obarray: SCM) -> SCM;
}
extern "C" {
    pub fn scm_intern_obarray_soft(
        name: *const ::std::os::raw::c_char,
        len: size_t,
        obarray: SCM,
        softness: ::std::os::raw::c_uint,
    ) -> SCM;
}
extern "C" {
    pub fn scm_intern_obarray(
        name: *const ::std::os::raw::c_char,
        len: size_t,
        obarray: SCM,
    ) -> SCM;
}
extern "C" {
    pub fn scm_symbol_value0(name: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_string_to_obarray_symbol(o: SCM, s: SCM, softp: SCM) -> SCM;
}
extern "C" {
    pub fn scm_intern_symbol(o: SCM, s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_unintern_symbol(o: SCM, s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_binding(o: SCM, s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_bound_p(o: SCM, s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_set_x(o: SCM, s: SCM, v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gentemp(prefix: SCM, obarray: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_makinum(val: scm_t_signed_bits) -> SCM;
}
extern "C" {
    pub fn scm_i_inump(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_inum(obj: SCM) -> scm_t_signed_bits;
}
extern "C" {
    pub fn scm_c_string2str(
        obj: SCM,
        str_: *mut ::std::os::raw::c_char,
        lenp: *mut size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_c_substring2str(
        obj: SCM,
        str_: *mut ::std::os::raw::c_char,
        start: size_t,
        len: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_c_symbol2str(
        obj: SCM,
        str_: *mut ::std::os::raw::c_char,
        lenp: *mut size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_truncate(x: f64) -> f64;
}
extern "C" {
    pub fn scm_round(x: f64) -> f64;
}
extern "C" {
    pub fn scm_sys_expt(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_asinh(x: f64) -> f64;
}
extern "C" {
    pub fn scm_acosh(x: f64) -> f64;
}
extern "C" {
    pub fn scm_atanh(x: f64) -> f64;
}
extern "C" {
    pub fn scm_sys_atan2(z1: SCM, z2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_deprecated_symbol_chars(sym: SCM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_deprecated_symbol_length(sym: SCM) -> size_t;
}
extern "C" {
    pub fn scm_i_keywordp(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_keywordsym(keyword: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_vectorp(x: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_vector_length(x: SCM) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_i_velts(x: SCM) -> *const SCM;
}
extern "C" {
    pub fn scm_i_writable_velts(x: SCM) -> *mut SCM;
}
extern "C" {
    pub fn scm_i_vector_ref(x: SCM, idx: size_t) -> SCM;
}
extern "C" {
    pub fn scm_i_vector_set(x: SCM, idx: size_t, val: SCM);
}
extern "C" {
    pub fn scm_vector_equal_p(x: SCM, y: SCM) -> SCM;
}
pub type scm_t_array = scm_i_t_array;
extern "C" {
    pub fn scm_i_arrayp(a: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_array_ndim(a: SCM) -> size_t;
}
extern "C" {
    pub fn scm_i_array_contp(a: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_array_mem(a: SCM) -> *mut scm_t_array;
}
extern "C" {
    pub fn scm_i_array_v(a: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_array_base(a: SCM) -> size_t;
}
extern "C" {
    pub fn scm_i_array_dims(a: SCM) -> *mut scm_t_array_dim;
}
extern "C" {
    pub fn scm_uniform_array_read_x(ra: SCM, port_or_fd: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_uniform_array_write(v: SCM, port_or_fd: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_cur_inp() -> SCM;
}
extern "C" {
    pub fn scm_i_cur_outp() -> SCM;
}
extern "C" {
    pub fn scm_i_cur_errp() -> SCM;
}
extern "C" {
    pub fn scm_i_cur_loadp() -> SCM;
}
extern "C" {
    pub fn scm_i_progargs() -> SCM;
}
extern "C" {
    pub fn scm_i_deprecated_dynwinds() -> SCM;
}
extern "C" {
    pub fn scm_i_stack_base() -> *mut SCM_STACKITEM;
}
extern "C" {
    pub fn scm_i_fluidp(x: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_defer_ints_etc();
}
extern "C" {
    pub fn scm_i_mask_ints() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_guard(guardian: SCM, obj: SCM, throw_p: ::std::os::raw::c_int) -> SCM;
}
extern "C" {
    pub fn scm_get_one_zombie(guardian: SCM) -> SCM;
}
extern "C" {
    pub fn scm_destroy_guardian_x(guardian: SCM) -> SCM;
}
extern "C" {
    pub fn scm_guardian_greedy_p(guardian: SCM) -> SCM;
}
extern "C" {
    pub fn scm_guardian_destroyed_p(guardian: SCM) -> SCM;
}
extern "C" {
    pub static mut scm_mallocated: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut scm_mtrigger: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut scm_max_segment_size: size_t;
}
extern "C" {
    pub fn scm_trampoline_0(proc_: SCM) -> scm_t_trampoline_0;
}
extern "C" {
    pub fn scm_trampoline_1(proc_: SCM) -> scm_t_trampoline_1;
}
extern "C" {
    pub fn scm_trampoline_2(proc_: SCM) -> scm_t_trampoline_2;
}
extern "C" {
    pub fn scm_i_subr_p(x: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_lazy_catch(tag: SCM, thunk: SCM, handler: SCM) -> SCM;
}
extern "C" {
    pub fn scm_internal_lazy_catch(
        tag: SCM,
        body: scm_t_catch_body,
        body_data: *mut ::std::os::raw::c_void,
        handler: scm_t_catch_handler,
        handler_data: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_raequal(ra0: SCM, ra1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynamic_args_call(symb: SCM, dobj: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_badargsp(formals: SCM, args: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_internal_stack_catch(
        tag: SCM,
        body: scm_t_catch_body,
        body_data: *mut ::std::os::raw::c_void,
        handler: scm_t_catch_handler,
        handler_data: *mut ::std::os::raw::c_void,
    ) -> SCM;
}
extern "C" {
    pub fn scm_short2num(n: ::std::os::raw::c_short) -> SCM;
}
extern "C" {
    pub fn scm_ushort2num(n: ::std::os::raw::c_ushort) -> SCM;
}
extern "C" {
    pub fn scm_int2num(n: ::std::os::raw::c_int) -> SCM;
}
extern "C" {
    pub fn scm_uint2num(n: ::std::os::raw::c_uint) -> SCM;
}
extern "C" {
    pub fn scm_long2num(n: ::std::os::raw::c_long) -> SCM;
}
extern "C" {
    pub fn scm_ulong2num(n: ::std::os::raw::c_ulong) -> SCM;
}
extern "C" {
    pub fn scm_size2num(n: size_t) -> SCM;
}
extern "C" {
    pub fn scm_ptrdiff2num(n: scm_t_ptrdiff) -> SCM;
}
extern "C" {
    pub fn scm_num2short(
        num: SCM,
        pos: ::std::os::raw::c_ulong,
        s_caller: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn scm_num2ushort(
        num: SCM,
        pos: ::std::os::raw::c_ulong,
        s_caller: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn scm_num2int(
        num: SCM,
        pos: ::std::os::raw::c_ulong,
        s_caller: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_num2uint(
        num: SCM,
        pos: ::std::os::raw::c_ulong,
        s_caller: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn scm_num2long(
        num: SCM,
        pos: ::std::os::raw::c_ulong,
        s_caller: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scm_num2ulong(
        num: SCM,
        pos: ::std::os::raw::c_ulong,
        s_caller: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_num2ptrdiff(
        num: SCM,
        pos: ::std::os::raw::c_ulong,
        s_caller: *const ::std::os::raw::c_char,
    ) -> scm_t_ptrdiff;
}
extern "C" {
    pub fn scm_num2size(
        num: SCM,
        pos: ::std::os::raw::c_ulong,
        s_caller: *const ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    pub fn scm_long_long2num(sl: ::std::os::raw::c_longlong) -> SCM;
}
extern "C" {
    pub fn scm_ulong_long2num(sl: ::std::os::raw::c_ulonglong) -> SCM;
}
extern "C" {
    pub fn scm_num2long_long(
        num: SCM,
        pos: ::std::os::raw::c_ulong,
        s_caller: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn scm_num2ulong_long(
        num: SCM,
        pos: ::std::os::raw::c_ulong,
        s_caller: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn scm_make_real(x: f64) -> SCM;
}
extern "C" {
    pub fn scm_num2dbl(a: SCM, why: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn scm_float2num(n: f32) -> SCM;
}
extern "C" {
    pub fn scm_double2num(n: f64) -> SCM;
}
extern "C" {
    pub fn scm_num2float(
        num: SCM,
        pos: ::std::os::raw::c_ulong,
        s_caller: *const ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn scm_num2double(
        num: SCM,
        pos: ::std::os::raw::c_ulong,
        s_caller: *const ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn scm_make_complex(x: f64, y: f64) -> SCM;
}
extern "C" {
    pub fn scm_mem2symbol(mem: *const ::std::os::raw::c_char, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_mem2uninterned_symbol(mem: *const ::std::os::raw::c_char, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_str2symbol(str_: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_take_str(s: *mut ::std::os::raw::c_char, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_take0str(s: *mut ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_mem2string(src: *const ::std::os::raw::c_char, len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_str2string(src: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_makfrom0str(src: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_makfrom0str_opt(src: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_allocate_string(len: size_t) -> SCM;
}
extern "C" {
    pub fn scm_make_keyword_from_dash_symbol(symbol: SCM) -> SCM;
}
extern "C" {
    pub fn scm_keyword_dash_symbol(keyword: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_make_keyword(s: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_thread_sleep(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn scm_thread_usleep(arg1: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_internal_select(
        fds: ::std::os::raw::c_int,
        rfds: *mut fd_set,
        wfds: *mut fd_set,
        efds: *mut fd_set,
        timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_cuserid() -> SCM;
}
extern "C" {
    pub fn scm_primitive_make_property(not_found_proc: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_property_ref(prop: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_property_set_x(prop: SCM, obj: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_property_del_x(prop: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_whash_get_handle(whash: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn SCM_WHASHFOUNDP(h: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCM_WHASHREF(whash: SCM, handle: SCM) -> SCM;
}
extern "C" {
    pub fn SCM_WHASHSET(whash: SCM, handle: SCM, obj: SCM);
}
extern "C" {
    pub fn scm_whash_create_handle(whash: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_whash_lookup(whash: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_whash_insert(whash: SCM, key: SCM, obj: SCM);
}
extern "C" {
    pub static mut scm_struct_table: SCM;
}
extern "C" {
    pub fn scm_struct_create_handle(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_immutable_cell(car: scm_t_bits, cdr: scm_t_bits) -> SCM;
}
extern "C" {
    pub fn scm_immutable_double_cell(
        car: scm_t_bits,
        cbr: scm_t_bits,
        ccr: scm_t_bits,
        cdr: scm_t_bits,
    ) -> SCM;
}
extern "C" {
    pub fn scm_i_deprecated_asrtgo(condition: scm_t_bits) -> scm_t_bits;
}
extern "C" {
    pub fn scm_sym2var(sym: SCM, thunk: SCM, definep: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lookup_closure_module(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_module_lookup_closure(module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_current_module_lookup_closure() -> SCM;
}
extern "C" {
    pub static mut scm_tc16_eval_closure: scm_t_bits;
}
extern "C" {
    pub fn scm_eval_closure_lookup(eclo: SCM, sym: SCM, definep: SCM) -> SCM;
}
extern "C" {
    pub fn scm_standard_eval_closure(module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_standard_interface_eval_closure(module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_eval_closure_module(eval_closure: SCM) -> SCM;
}
extern "C" {
    pub fn scm_struct_vtable_tag(handle: SCM) -> SCM;
}
extern "C" {
    pub fn scm_generalized_vector_p(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_generalized_vector_length(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_generalized_vector_ref(v: SCM, idx: SCM) -> SCM;
}
extern "C" {
    pub fn scm_generalized_vector_set_x(v: SCM, idx: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_generalized_vector_to_list(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_program_source(program: SCM, ip: size_t) -> SCM;
}
extern "C" {
    pub fn scm_gc_live_object_stats() -> SCM;
}
extern "C" {
    pub fn scm_htons(in_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ntohs(in_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_htonl(in_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ntohl(in_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_init_deprecated();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
